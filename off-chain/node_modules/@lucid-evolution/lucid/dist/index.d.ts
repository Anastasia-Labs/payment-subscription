import { PrivateKey, Address, UTxO, Assets, ScriptType, Script, RewardAddress, Lovelace, PoolId, Redeemer, Label, Wallet, Provider, Transaction, WalletApi, Credential, OutRef, Delegation, Network, ProtocolParameters } from '@lucid-evolution/core-types';
export * from '@lucid-evolution/core-types';
import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';
import { Either } from 'effect/Either';
import { Effect } from 'effect';
import * as effect_Cause from 'effect/Cause';
import * as effect_Types from 'effect/Types';
import { Data } from '@lucid-evolution/plutus';
export * from '@lucid-evolution/plutus';
export * from '@lucid-evolution/bip39';
export * from '@lucid-evolution/core-utils';
export * from '@lucid-evolution/provider';
export * from '@lucid-evolution/sign_data';
export * from '@lucid-evolution/utils';
export * from '@lucid-evolution/wallet';

type Hash = string;
type CBORHex = string;
type OutputDatum = {
    kind: "hash";
    value: Hash;
} | {
    kind: "asHash";
    value: CBORHex;
} | {
    kind: "inline";
    value: CBORHex;
};

type TransactionMetadata = string | number | Uint8Array | ReadonlyArray<TransactionMetadata> | {
    [key: string]: TransactionMetadata;
};

declare const ERROR_MESSAGE: {
    MULTIPLE_POLICIES: string;
    EMPTY_UTXO: string;
    MISSING_WALLET: string;
    MISSING_REDEEMER: string;
};
type TxBuilderErrorCause = "UPLCEval" | "BuildEvaluation" | "Build" | "Datum" | "NotFound" | "Provider" | "EmptyUTXO" | "EmptyAssets" | "MissingCollateral" | "MultiplePolicies" | "InvalidNetwork" | "InvalidMetadata" | "MissingWallet" | "MissingScript" | "MissingPolicy" | "MissingRedeemer" | "MissingStakeCredential" | "Address" | "InvalidCredential";
type TxBuilderErrorModule = "Attach" | "Collect" | "Governance" | "Interval" | "Mint" | "Pay" | "Read" | "Signer" | "Stake" | "Pool" | "Complete";
declare const TxBuilderError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "TxBuilderError";
} & Readonly<A>;
declare class TxBuilderError extends TxBuilderError_base<{
    readonly cause: TxBuilderErrorCause;
    readonly module?: TxBuilderErrorModule;
    readonly message?: string;
}> {
}
type TransactionError = RunTimeError | TxBuilderError;
type TxSignerErrorCause = "MissingWallet" | "Signature";
type TxSignerErrorModule = "Sign" | "Complete";
declare const TxSignerError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "TxSignerError";
} & Readonly<A>;
declare class TxSignerError extends TxSignerError_base<{
    readonly cause: TxSignerErrorCause;
    readonly module: TxSignerErrorModule;
    readonly message?: string;
}> {
}
type TransactionSignError = RunTimeError | TxSignerError;
type TxSubmitErrorModule = "Submit";
declare const TxSubmitError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "TxSubmitError";
} & Readonly<A>;
declare class TxSubmitError extends TxSubmitError_base<{
    readonly cause: string;
    readonly module: TxSubmitErrorModule;
    readonly message?: string;
}> {
}
declare const RunTimeError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "RunTimeError";
} & Readonly<A>;
declare class RunTimeError extends RunTimeError_base<{
    message: string;
}> {
}
declare const makeRunTimeError: (error: unknown) => Effect.Effect<never, RunTimeError>;

type TxSigned = {
    submit: () => Promise<string>;
    submitProgram: () => Effect.Effect<string, TxSubmitError, never>;
    submitSafe: () => Promise<Either<string, TxSubmitError>>;
    toCBOR: () => string;
    toHash: () => string;
};

declare const signError: (cause: TxSignerErrorCause, message?: string) => TxSignerError;
type TxSignBuilderConfig = {
    txComplete: CML.Transaction;
    witnessSetBuilder: CML.TransactionWitnessSetBuilder;
    programs: Effect.Effect<void, TransactionSignError, never>[];
    lucidConfig: LucidConfig;
    fee: number;
    exUnits: {
        cpu: number;
        mem: number;
    } | null;
};
type TxSignBuilder = {
    sign: {
        withWallet: () => TxSignBuilder;
        withPrivateKey: (privateKey: PrivateKey) => TxSignBuilder;
    };
    complete: () => Promise<TxSigned>;
    completeProgram: () => Effect.Effect<TxSigned, TransactionSignError, never>;
    completeSafe: () => Promise<Either<TxSigned, TransactionSignError>>;
};
declare const makeTxSignBuilder: (lucidConfig: LucidConfig, tx: CML.Transaction) => TxSignBuilder;

type CompleteOptions = {
    coinSelection?: boolean;
    changeAddress?: Address;
    localUPLCEval?: boolean;
};

type TxBuilderConfig = {
    readonly lucidConfig: LucidConfig;
    readonly txBuilder: CML.TransactionBuilder;
    walletInputs: UTxO[];
    collectedInputs: UTxO[];
    readInputs: UTxO[];
    consumedInputs: UTxO[];
    totalOutputAssets: Assets;
    mintedAssets: Assets;
    scripts: Map<string, {
        type: ScriptType;
        script: string;
    }>;
    programs: Effect.Effect<void, TransactionError, never>[];
};
type TxBuilder = {
    readFrom: (utxos: UTxO[]) => TxBuilder;
    collectFrom: (utxos: UTxO[], redeemer?: string | undefined) => TxBuilder;
    pay: {
        ToAddress: (address: string, assets: Assets) => TxBuilder;
        ToAddressWithData: (address: string, outputDatum: OutputDatum, assets?: Assets | undefined, scriptRef?: Script | undefined) => TxBuilder;
        ToContract: (address: string, outputDatum: OutputDatum, assets?: Assets | undefined, scriptRef?: Script | undefined) => TxBuilder;
    };
    addSigner: (address: Address) => TxBuilder;
    registerStake: (rewardAddress: RewardAddress) => TxBuilder;
    deRegisterStake: (rewardAddress: RewardAddress, redeemer?: string) => TxBuilder;
    withdraw: (rewardAddress: RewardAddress, amount: Lovelace, redeemer?: string) => TxBuilder;
    mintAssets: (assets: Assets, redeemer?: string | undefined) => TxBuilder;
    validFrom: (unixTime: number) => TxBuilder;
    validTo: (unixTime: number) => TxBuilder;
    delegateTo: (rewardAddress: RewardAddress, poolId: PoolId, redeemer?: Redeemer) => TxBuilder;
    attachMetadata: (label: Label, metadata: TransactionMetadata) => TxBuilder;
    attach: {
        Script: (script: Script) => TxBuilder;
        SpendingValidator: (spendingValidator: Script) => TxBuilder;
        MintingPolicy: (mintingPolicy: Script) => TxBuilder;
        CertificateValidator: (certValidator: Script) => TxBuilder;
        WithdrawalValidator: (withdrawalValidator: Script) => TxBuilder;
    };
    complete: (options?: CompleteOptions) => Promise<TxSignBuilder>;
    completeProgram: (options?: CompleteOptions) => Effect.Effect<TxSignBuilder, TransactionError>;
    completeSafe: (options?: CompleteOptions) => Promise<Either<TxSignBuilder, TransactionError>>;
    chainProgram: () => Effect.Effect<[
        UTxO[],
        UTxO[],
        TxSignBuilder
    ], TransactionError, never>;
    chain: () => Promise<[UTxO[], UTxO[], TxSignBuilder]>;
    chainSafe: () => Promise<Either<[UTxO[], UTxO[], TxSignBuilder], TransactionError>>;
    config: () => TxBuilderConfig;
};
declare function makeTxBuilder(lucidConfig: LucidConfig): TxBuilder;

type LucidEvolution = {
    config: () => LucidConfig;
    wallet: () => Wallet;
    overrideUTxOs: (utxos: UTxO[]) => void;
    switchProvider: (provider: Provider) => Promise<void>;
    newTx: () => TxBuilder;
    fromTx: (tx: Transaction) => TxSignBuilder;
    selectWallet: {
        fromSeed: (seed: string) => void;
        fromPrivateKey: (privateKey: PrivateKey) => void;
        fromAPI: (walletAPI: WalletApi) => void;
        fromAddress: (address: string, utxos: UTxO[]) => void;
    };
    currentSlot: () => number;
    utxosAt: (addressOrCredential: string | Credential) => Promise<UTxO[]>;
    utxosAtWithUnit: (addressOrCredential: string | Credential, unit: string) => Promise<UTxO[]>;
    utxoByUnit: (unit: string) => Promise<UTxO>;
    utxosByOutRef: (outRefs: OutRef[]) => Promise<UTxO[]>;
    delegationAt: (rewardAddress: string) => Promise<Delegation>;
    awaitTx: (txHash: string, checkInterval?: number | undefined) => Promise<boolean>;
    datumOf: <T extends Data>(utxo: UTxO, type?: T | undefined) => Promise<T>;
    metadataOf: <T = any>(unit: string) => Promise<T>;
};
type LucidConfig = {
    provider: Provider;
    network: Network;
    wallet: Wallet | undefined;
    txbuilderconfig: CML.TransactionBuilderConfig;
    costModels: CML.CostModels;
    protocolParameters: ProtocolParameters;
};
declare const Lucid: (provider: Provider, network: Network) => Promise<LucidEvolution>;

export { type CBORHex, ERROR_MESSAGE, type Hash, Lucid, type LucidConfig, type LucidEvolution, type OutputDatum, RunTimeError, type TransactionError, type TransactionSignError, type TxBuilder, type TxBuilderConfig, TxBuilderError, type TxBuilderErrorCause, type TxBuilderErrorModule, type TxSignBuilder, type TxSignBuilderConfig, TxSignerError, type TxSignerErrorCause, type TxSignerErrorModule, TxSubmitError, type TxSubmitErrorModule, makeRunTimeError, makeTxBuilder, makeTxSignBuilder, signError };
