// src/native.ts
import * as S from "@effect/schema/Schema";

// src/core.ts
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/native.ts
var toCMLNativeScript = (native) => {
  switch (native.type) {
    case "sig":
      return CML.NativeScript.new_script_pubkey(
        CML.Ed25519KeyHash.from_hex(native.keyHash)
      );
    case "before":
      return CML.NativeScript.new_script_invalid_hereafter(BigInt(native.slot));
    case "after":
      return CML.NativeScript.new_script_invalid_before(BigInt(native.slot));
    case "all": {
      const nativeList = CML.NativeScriptList.new();
      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
      return CML.NativeScript.new_script_all(nativeList);
    }
    case "any": {
      const nativeList = CML.NativeScriptList.new();
      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
      return CML.NativeScript.new_script_any(nativeList);
    }
    case "atLeast": {
      const nativeList = CML.NativeScriptList.new();
      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
      return CML.NativeScript.new_script_n_of_k(
        BigInt(native.required),
        nativeList
      );
    }
  }
};
var scriptFromNative = (native) => {
  return {
    type: "Native",
    script: toCMLNativeScript(native).to_cbor_hex()
  };
};
var CMLNativeSchema = S.Union(
  S.Struct({
    ScriptPubkey: S.Struct({
      ed25519_key_hash: S.String
    })
  }),
  S.Struct({
    ScriptInvalidBefore: S.Struct({
      before: S.Number
    })
  }),
  S.Struct({
    ScriptInvalidHereafter: S.Struct({
      after: S.Number
    })
  }),
  S.Struct({
    ScriptAll: S.Struct({
      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
    })
  }),
  S.Struct({
    ScriptAny: S.Struct({
      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
    })
  }),
  S.Struct({
    ScriptNOfK: S.Struct({
      n: S.Number,
      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
    })
  })
);
var parseCMLNative = S.decodeUnknownSync(CMLNativeSchema);
var scriptFromCMLNative = (cmlNative) => {
  return {
    type: "Native",
    script: CML.NativeScript.from_json(JSON.stringify(cmlNative)).to_cbor_hex()
  };
};

// src/network.ts
function networkToId(network) {
  switch (network) {
    case "Preview":
      return 0;
    case "Preprod":
      return 0;
    case "Custom":
      return 0;
    case "Mainnet":
      return 1;
    default:
      throw new Error("Network not found");
  }
}

// src/cbor.ts
import { fromHex, toHex } from "@lucid-evolution/core-utils";
import { decode, encode } from "cborg";
var applyDoubleCborEncoding = (script) => {
  try {
    decode(decode(fromHex(script)));
    return script;
  } catch (error) {
    return toHex(encode(fromHex(script)));
  }
};

// src/scripts.ts
import { Data } from "@lucid-evolution/plutus";
import * as UPLC from "@lucid-evolution/uplc";
import { fromHex as fromHex2, toHex as toHex2 } from "@lucid-evolution/core-utils";
function validatorToAddress(network, validator, stakeCredential) {
  const validatorHash = validatorToScriptHash(validator);
  if (stakeCredential) {
    return CML.BaseAddress.new(
      networkToId(network),
      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash)),
      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(stakeCredential.hash)
      )
    ).to_address().to_bech32(void 0);
  } else {
    return CML.EnterpriseAddress.new(
      networkToId(network),
      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
    ).to_address().to_bech32(void 0);
  }
}
function validatorToScriptHash(validator) {
  switch (validator.type) {
    case "Native":
      return CML.NativeScript.from_cbor_hex(validator.script).hash().to_hex();
    case "PlutusV1":
      return CML.PlutusScript.from_v1(
        CML.PlutusV1Script.from_cbor_hex(
          applyDoubleCborEncoding(validator.script)
        )
      ).hash().to_hex();
    case "PlutusV2":
      return CML.PlutusScript.from_v2(
        CML.PlutusV2Script.from_cbor_hex(
          applyDoubleCborEncoding(validator.script)
        )
      ).hash().to_hex();
    default:
      throw new Error("No variant matched");
  }
}
function toScriptRef(script) {
  switch (script.type) {
    case "Native":
      return CML.Script.new_native(
        CML.NativeScript.from_cbor_hex(script.script)
      );
    case "PlutusV1":
      return CML.Script.new_plutus_v1(
        CML.PlutusV1Script.from_cbor_hex(
          applyDoubleCborEncoding(script.script)
        )
      );
    case "PlutusV2":
      return CML.Script.new_plutus_v2(
        CML.PlutusV2Script.from_cbor_hex(
          applyDoubleCborEncoding(script.script)
        )
      );
    default:
      throw new Error("No variant matched.");
  }
}
function fromScriptRef(scriptRef) {
  const kind = scriptRef.kind();
  switch (kind) {
    case 0:
      return {
        type: "Native",
        script: scriptRef.as_native().to_cbor_hex()
      };
    case 1:
      return {
        type: "PlutusV1",
        script: scriptRef.as_plutus_v1().to_cbor_hex()
      };
    case 2:
      return {
        type: "PlutusV2",
        script: scriptRef.as_plutus_v2().to_cbor_hex()
      };
    default:
      throw new Error("No variant matched.");
  }
}
function mintingPolicyToId(mintingPolicy) {
  return validatorToScriptHash(mintingPolicy);
}
function applyParamsToScript(plutusScript, params, type) {
  const p = type ? Data.castTo(params, type) : params;
  return toHex2(
    UPLC.apply_params_to_script(fromHex2(Data.to(p)), fromHex2(plutusScript))
  );
}

// src/address.ts
function addressFromHexOrBech32(address) {
  try {
    return CML.Address.from_hex(address);
  } catch (_e) {
    try {
      return CML.Address.from_bech32(address);
    } catch (_e2) {
      throw new Error("Could not deserialize address.");
    }
  }
}
function credentialToRewardAddress(network, stakeCredential) {
  return CML.RewardAddress.new(
    networkToId(network),
    stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
      CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
    ) : CML.Credential.new_script(
      CML.ScriptHash.from_hex(stakeCredential.hash)
    )
  ).to_address().to_bech32(void 0);
}
function validatorToRewardAddress(network, validator) {
  const validatorHash = validatorToScriptHash(validator);
  return CML.RewardAddress.new(
    networkToId(network),
    CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
  ).to_address().to_bech32(void 0);
}
function getAddressDetails(address) {
  try {
    const parsedAddress = CML.BaseAddress.from_address(
      CML.Address.from_bech32(address)
    );
    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
      type: "Key",
      // hash: toHex(
      //   parsedAddress.payment_cred().to_keyhash()!.to_bytes(),
      // ),
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      // hash: toHex(
      //   parsedAddress.payment_cred().to_scripthash()!.to_bytes(),
      // ),
      hash: parsedAddress.payment().as_script().to_hex()
    };
    const stakeCredential = parsedAddress.stake().kind() === 0 ? (
      // parsedAddress.stake_cred().kind() === 0
      {
        type: "Key",
        hash: parsedAddress.stake().as_pub_key().to_hex()
        // hash: toHex(parsedAddress.stake_cred().to_keyhash()!.to_bytes()),
      }
    ) : {
      type: "Script",
      // hash: toHex(parsedAddress.stake_cred().to_scripthash()!.to_bytes()),
      hash: parsedAddress.stake().as_script().to_hex()
    };
    return {
      type: "Base",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        // hex: toHex(parsedAddress.to_address().to_bytes()),
        hex: parsedAddress.to_address().to_hex()
      },
      paymentCredential,
      stakeCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = CML.EnterpriseAddress.from_address(
      CML.Address.from_bech32(address)
    );
    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
      type: "Key",
      // hash: toHex(parsedAddress.payment_cred().to_keyhash()!.to_bytes()),
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: (
        // parsedAddress.payment_cred().to_scripthash()!.to_bytes()
        parsedAddress.payment().as_script().to_hex()
      )
    };
    return {
      type: "Enterprise",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        hex: parsedAddress.to_address().to_hex()
      },
      paymentCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = CML.PointerAddress.from_address(
      CML.Address.from_bech32(address)
    );
    const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
      type: "Key",
      // hash: toHex(parsedAddress.payment_cred().to_keyhash()!.to_bytes()),
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      // hash: toHex( parsedAddress.payment_cred().to_scripthash()!.to_bytes()),
      hash: parsedAddress.payment().as_script().to_hex()
    };
    return {
      type: "Pointer",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        // hex: toHex(parsedAddress.to_address().to_bytes()),
        hex: parsedAddress.to_address().to_hex()
      },
      paymentCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = CML.RewardAddress.from_address(
      CML.Address.from_bech32(address)
    );
    const stakeCredential = parsedAddress.payment().kind() === 0 ? {
      type: "Key",
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: parsedAddress.payment().as_script().to_hex()
    };
    return {
      type: "Reward",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        // hex: toHex(parsedAddress.to_address().to_bytes()),
        hex: parsedAddress.to_address().to_hex()
      },
      stakeCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = ((address2) => {
      try {
        return CML.ByronAddress.from_cbor_hex(address2);
      } catch (_e) {
        try {
          return CML.ByronAddress.from_base58(address2);
        } catch (_e2) {
          throw new Error("Could not deserialize address.");
        }
      }
    })(address);
    return {
      type: "Byron",
      networkId: parsedAddress.content().network_id(),
      address: {
        bech32: "",
        // hex: toHex(parsedAddress.to_address().to_bytes()),
        hex: parsedAddress.to_address().to_hex()
      }
    };
  } catch (_e) {
  }
  throw new Error("No address type matched for: " + address);
}

// src/cost_model.ts
function createCostModels(costModels) {
  const costmdls = CML.CostModels.new();
  const costmdlV1 = CML.IntList.new();
  for (const cost of Object.values(costModels.PlutusV1)) {
    const int = CML.Int.from_str(cost.toString());
    costmdlV1.add(int);
    int.free();
  }
  costmdls.set_plutus_v1(costmdlV1);
  costmdlV1.free();
  const costmdlV2 = CML.IntList.new();
  for (const cost of Object.values(costModels.PlutusV2)) {
    const int = CML.Int.from_str(cost.toString());
    costmdlV2.add(int);
    int.free();
  }
  costmdls.set_plutus_v2(costmdlV2);
  costmdlV2.free();
  return costmdls;
}
var PROTOCOL_PARAMETERS_DEFAULT = {
  minFeeA: 44,
  minFeeB: 155381,
  maxTxSize: 16384,
  maxValSize: 5e3,
  keyDeposit: 2000000n,
  poolDeposit: 500000000n,
  priceMem: 0.0577,
  priceStep: 721e-7,
  maxTxExMem: 14000000n,
  maxTxExSteps: 10000000000n,
  coinsPerUtxoByte: 4310n,
  collateralPercentage: 150,
  maxCollateralInputs: 3,
  costModels: {
    PlutusV1: {
      "addInteger-cpu-arguments-intercept": 205665,
      "addInteger-cpu-arguments-slope": 812,
      "addInteger-memory-arguments-intercept": 1,
      "addInteger-memory-arguments-slope": 1,
      "appendByteString-cpu-arguments-intercept": 1e3,
      "appendByteString-cpu-arguments-slope": 571,
      "appendByteString-memory-arguments-intercept": 0,
      "appendByteString-memory-arguments-slope": 1,
      "appendString-cpu-arguments-intercept": 1e3,
      "appendString-cpu-arguments-slope": 24177,
      "appendString-memory-arguments-intercept": 4,
      "appendString-memory-arguments-slope": 1,
      "bData-cpu-arguments": 1e3,
      "bData-memory-arguments": 32,
      "blake2b_256-cpu-arguments-intercept": 117366,
      "blake2b_256-cpu-arguments-slope": 10475,
      "blake2b_256-memory-arguments": 4,
      "cekApplyCost-exBudgetCPU": 23e3,
      "cekApplyCost-exBudgetMemory": 100,
      "cekBuiltinCost-exBudgetCPU": 23e3,
      "cekBuiltinCost-exBudgetMemory": 100,
      "cekConstCost-exBudgetCPU": 23e3,
      "cekConstCost-exBudgetMemory": 100,
      "cekDelayCost-exBudgetCPU": 23e3,
      "cekDelayCost-exBudgetMemory": 100,
      "cekForceCost-exBudgetCPU": 23e3,
      "cekForceCost-exBudgetMemory": 100,
      "cekLamCost-exBudgetCPU": 23e3,
      "cekLamCost-exBudgetMemory": 100,
      "cekStartupCost-exBudgetCPU": 100,
      "cekStartupCost-exBudgetMemory": 100,
      "cekVarCost-exBudgetCPU": 23e3,
      "cekVarCost-exBudgetMemory": 100,
      "chooseData-cpu-arguments": 19537,
      "chooseData-memory-arguments": 32,
      "chooseList-cpu-arguments": 175354,
      "chooseList-memory-arguments": 32,
      "chooseUnit-cpu-arguments": 46417,
      "chooseUnit-memory-arguments": 4,
      "consByteString-cpu-arguments-intercept": 221973,
      "consByteString-cpu-arguments-slope": 511,
      "consByteString-memory-arguments-intercept": 0,
      "consByteString-memory-arguments-slope": 1,
      "constrData-cpu-arguments": 89141,
      "constrData-memory-arguments": 32,
      "decodeUtf8-cpu-arguments-intercept": 497525,
      "decodeUtf8-cpu-arguments-slope": 14068,
      "decodeUtf8-memory-arguments-intercept": 4,
      "decodeUtf8-memory-arguments-slope": 2,
      "divideInteger-cpu-arguments-constant": 196500,
      "divideInteger-cpu-arguments-model-arguments-intercept": 453240,
      "divideInteger-cpu-arguments-model-arguments-slope": 220,
      "divideInteger-memory-arguments-intercept": 0,
      "divideInteger-memory-arguments-minimum": 1,
      "divideInteger-memory-arguments-slope": 1,
      "encodeUtf8-cpu-arguments-intercept": 1e3,
      "encodeUtf8-cpu-arguments-slope": 28662,
      "encodeUtf8-memory-arguments-intercept": 4,
      "encodeUtf8-memory-arguments-slope": 2,
      "equalsByteString-cpu-arguments-constant": 245e3,
      "equalsByteString-cpu-arguments-intercept": 216773,
      "equalsByteString-cpu-arguments-slope": 62,
      "equalsByteString-memory-arguments": 1,
      "equalsData-cpu-arguments-intercept": 1060367,
      "equalsData-cpu-arguments-slope": 12586,
      "equalsData-memory-arguments": 1,
      "equalsInteger-cpu-arguments-intercept": 208512,
      "equalsInteger-cpu-arguments-slope": 421,
      "equalsInteger-memory-arguments": 1,
      "equalsString-cpu-arguments-constant": 187e3,
      "equalsString-cpu-arguments-intercept": 1e3,
      "equalsString-cpu-arguments-slope": 52998,
      "equalsString-memory-arguments": 1,
      "fstPair-cpu-arguments": 80436,
      "fstPair-memory-arguments": 32,
      "headList-cpu-arguments": 43249,
      "headList-memory-arguments": 32,
      "iData-cpu-arguments": 1e3,
      "iData-memory-arguments": 32,
      "ifThenElse-cpu-arguments": 80556,
      "ifThenElse-memory-arguments": 1,
      "indexByteString-cpu-arguments": 57667,
      "indexByteString-memory-arguments": 4,
      "lengthOfByteString-cpu-arguments": 1e3,
      "lengthOfByteString-memory-arguments": 10,
      "lessThanByteString-cpu-arguments-intercept": 197145,
      "lessThanByteString-cpu-arguments-slope": 156,
      "lessThanByteString-memory-arguments": 1,
      "lessThanEqualsByteString-cpu-arguments-intercept": 197145,
      "lessThanEqualsByteString-cpu-arguments-slope": 156,
      "lessThanEqualsByteString-memory-arguments": 1,
      "lessThanEqualsInteger-cpu-arguments-intercept": 204924,
      "lessThanEqualsInteger-cpu-arguments-slope": 473,
      "lessThanEqualsInteger-memory-arguments": 1,
      "lessThanInteger-cpu-arguments-intercept": 208896,
      "lessThanInteger-cpu-arguments-slope": 511,
      "lessThanInteger-memory-arguments": 1,
      "listData-cpu-arguments": 52467,
      "listData-memory-arguments": 32,
      "mapData-cpu-arguments": 64832,
      "mapData-memory-arguments": 32,
      "mkCons-cpu-arguments": 65493,
      "mkCons-memory-arguments": 32,
      "mkNilData-cpu-arguments": 22558,
      "mkNilData-memory-arguments": 32,
      "mkNilPairData-cpu-arguments": 16563,
      "mkNilPairData-memory-arguments": 32,
      "mkPairData-cpu-arguments": 76511,
      "mkPairData-memory-arguments": 32,
      "modInteger-cpu-arguments-constant": 196500,
      "modInteger-cpu-arguments-model-arguments-intercept": 453240,
      "modInteger-cpu-arguments-model-arguments-slope": 220,
      "modInteger-memory-arguments-intercept": 0,
      "modInteger-memory-arguments-minimum": 1,
      "modInteger-memory-arguments-slope": 1,
      "multiplyInteger-cpu-arguments-intercept": 69522,
      "multiplyInteger-cpu-arguments-slope": 11687,
      "multiplyInteger-memory-arguments-intercept": 0,
      "multiplyInteger-memory-arguments-slope": 1,
      "nullList-cpu-arguments": 60091,
      "nullList-memory-arguments": 32,
      "quotientInteger-cpu-arguments-constant": 196500,
      "quotientInteger-cpu-arguments-model-arguments-intercept": 453240,
      "quotientInteger-cpu-arguments-model-arguments-slope": 220,
      "quotientInteger-memory-arguments-intercept": 0,
      "quotientInteger-memory-arguments-minimum": 1,
      "quotientInteger-memory-arguments-slope": 1,
      "remainderInteger-cpu-arguments-constant": 196500,
      "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
      "remainderInteger-cpu-arguments-model-arguments-slope": 220,
      "remainderInteger-memory-arguments-intercept": 0,
      "remainderInteger-memory-arguments-minimum": 1,
      "remainderInteger-memory-arguments-slope": 1,
      "sha2_256-cpu-arguments-intercept": 806990,
      "sha2_256-cpu-arguments-slope": 30482,
      "sha2_256-memory-arguments": 4,
      "sha3_256-cpu-arguments-intercept": 1927926,
      "sha3_256-cpu-arguments-slope": 82523,
      "sha3_256-memory-arguments": 4,
      "sliceByteString-cpu-arguments-intercept": 265318,
      "sliceByteString-cpu-arguments-slope": 0,
      "sliceByteString-memory-arguments-intercept": 4,
      "sliceByteString-memory-arguments-slope": 0,
      "sndPair-cpu-arguments": 85931,
      "sndPair-memory-arguments": 32,
      "subtractInteger-cpu-arguments-intercept": 205665,
      "subtractInteger-cpu-arguments-slope": 812,
      "subtractInteger-memory-arguments-intercept": 1,
      "subtractInteger-memory-arguments-slope": 1,
      "tailList-cpu-arguments": 41182,
      "tailList-memory-arguments": 32,
      "trace-cpu-arguments": 212342,
      "trace-memory-arguments": 32,
      "unBData-cpu-arguments": 31220,
      "unBData-memory-arguments": 32,
      "unConstrData-cpu-arguments": 32696,
      "unConstrData-memory-arguments": 32,
      "unIData-cpu-arguments": 43357,
      "unIData-memory-arguments": 32,
      "unListData-cpu-arguments": 32247,
      "unListData-memory-arguments": 32,
      "unMapData-cpu-arguments": 38314,
      "unMapData-memory-arguments": 32,
      "verifyEd25519Signature-cpu-arguments-intercept": 9462713,
      "verifyEd25519Signature-cpu-arguments-slope": 1021,
      "verifyEd25519Signature-memory-arguments": 10
    },
    PlutusV2: {
      "addInteger-cpu-arguments-intercept": 205665,
      "addInteger-cpu-arguments-slope": 812,
      "addInteger-memory-arguments-intercept": 1,
      "addInteger-memory-arguments-slope": 1,
      "appendByteString-cpu-arguments-intercept": 1e3,
      "appendByteString-cpu-arguments-slope": 571,
      "appendByteString-memory-arguments-intercept": 0,
      "appendByteString-memory-arguments-slope": 1,
      "appendString-cpu-arguments-intercept": 1e3,
      "appendString-cpu-arguments-slope": 24177,
      "appendString-memory-arguments-intercept": 4,
      "appendString-memory-arguments-slope": 1,
      "bData-cpu-arguments": 1e3,
      "bData-memory-arguments": 32,
      "blake2b_256-cpu-arguments-intercept": 117366,
      "blake2b_256-cpu-arguments-slope": 10475,
      "blake2b_256-memory-arguments": 4,
      "cekApplyCost-exBudgetCPU": 23e3,
      "cekApplyCost-exBudgetMemory": 100,
      "cekBuiltinCost-exBudgetCPU": 23e3,
      "cekBuiltinCost-exBudgetMemory": 100,
      "cekConstCost-exBudgetCPU": 23e3,
      "cekConstCost-exBudgetMemory": 100,
      "cekDelayCost-exBudgetCPU": 23e3,
      "cekDelayCost-exBudgetMemory": 100,
      "cekForceCost-exBudgetCPU": 23e3,
      "cekForceCost-exBudgetMemory": 100,
      "cekLamCost-exBudgetCPU": 23e3,
      "cekLamCost-exBudgetMemory": 100,
      "cekStartupCost-exBudgetCPU": 100,
      "cekStartupCost-exBudgetMemory": 100,
      "cekVarCost-exBudgetCPU": 23e3,
      "cekVarCost-exBudgetMemory": 100,
      "chooseData-cpu-arguments": 19537,
      "chooseData-memory-arguments": 32,
      "chooseList-cpu-arguments": 175354,
      "chooseList-memory-arguments": 32,
      "chooseUnit-cpu-arguments": 46417,
      "chooseUnit-memory-arguments": 4,
      "consByteString-cpu-arguments-intercept": 221973,
      "consByteString-cpu-arguments-slope": 511,
      "consByteString-memory-arguments-intercept": 0,
      "consByteString-memory-arguments-slope": 1,
      "constrData-cpu-arguments": 89141,
      "constrData-memory-arguments": 32,
      "decodeUtf8-cpu-arguments-intercept": 497525,
      "decodeUtf8-cpu-arguments-slope": 14068,
      "decodeUtf8-memory-arguments-intercept": 4,
      "decodeUtf8-memory-arguments-slope": 2,
      "divideInteger-cpu-arguments-constant": 196500,
      "divideInteger-cpu-arguments-model-arguments-intercept": 453240,
      "divideInteger-cpu-arguments-model-arguments-slope": 220,
      "divideInteger-memory-arguments-intercept": 0,
      "divideInteger-memory-arguments-minimum": 1,
      "divideInteger-memory-arguments-slope": 1,
      "encodeUtf8-cpu-arguments-intercept": 1e3,
      "encodeUtf8-cpu-arguments-slope": 28662,
      "encodeUtf8-memory-arguments-intercept": 4,
      "encodeUtf8-memory-arguments-slope": 2,
      "equalsByteString-cpu-arguments-constant": 245e3,
      "equalsByteString-cpu-arguments-intercept": 216773,
      "equalsByteString-cpu-arguments-slope": 62,
      "equalsByteString-memory-arguments": 1,
      "equalsData-cpu-arguments-intercept": 1060367,
      "equalsData-cpu-arguments-slope": 12586,
      "equalsData-memory-arguments": 1,
      "equalsInteger-cpu-arguments-intercept": 208512,
      "equalsInteger-cpu-arguments-slope": 421,
      "equalsInteger-memory-arguments": 1,
      "equalsString-cpu-arguments-constant": 187e3,
      "equalsString-cpu-arguments-intercept": 1e3,
      "equalsString-cpu-arguments-slope": 52998,
      "equalsString-memory-arguments": 1,
      "fstPair-cpu-arguments": 80436,
      "fstPair-memory-arguments": 32,
      "headList-cpu-arguments": 43249,
      "headList-memory-arguments": 32,
      "iData-cpu-arguments": 1e3,
      "iData-memory-arguments": 32,
      "ifThenElse-cpu-arguments": 80556,
      "ifThenElse-memory-arguments": 1,
      "indexByteString-cpu-arguments": 57667,
      "indexByteString-memory-arguments": 4,
      "lengthOfByteString-cpu-arguments": 1e3,
      "lengthOfByteString-memory-arguments": 10,
      "lessThanByteString-cpu-arguments-intercept": 197145,
      "lessThanByteString-cpu-arguments-slope": 156,
      "lessThanByteString-memory-arguments": 1,
      "lessThanEqualsByteString-cpu-arguments-intercept": 197145,
      "lessThanEqualsByteString-cpu-arguments-slope": 156,
      "lessThanEqualsByteString-memory-arguments": 1,
      "lessThanEqualsInteger-cpu-arguments-intercept": 204924,
      "lessThanEqualsInteger-cpu-arguments-slope": 473,
      "lessThanEqualsInteger-memory-arguments": 1,
      "lessThanInteger-cpu-arguments-intercept": 208896,
      "lessThanInteger-cpu-arguments-slope": 511,
      "lessThanInteger-memory-arguments": 1,
      "listData-cpu-arguments": 52467,
      "listData-memory-arguments": 32,
      "mapData-cpu-arguments": 64832,
      "mapData-memory-arguments": 32,
      "mkCons-cpu-arguments": 65493,
      "mkCons-memory-arguments": 32,
      "mkNilData-cpu-arguments": 22558,
      "mkNilData-memory-arguments": 32,
      "mkNilPairData-cpu-arguments": 16563,
      "mkNilPairData-memory-arguments": 32,
      "mkPairData-cpu-arguments": 76511,
      "mkPairData-memory-arguments": 32,
      "modInteger-cpu-arguments-constant": 196500,
      "modInteger-cpu-arguments-model-arguments-intercept": 453240,
      "modInteger-cpu-arguments-model-arguments-slope": 220,
      "modInteger-memory-arguments-intercept": 0,
      "modInteger-memory-arguments-minimum": 1,
      "modInteger-memory-arguments-slope": 1,
      "multiplyInteger-cpu-arguments-intercept": 69522,
      "multiplyInteger-cpu-arguments-slope": 11687,
      "multiplyInteger-memory-arguments-intercept": 0,
      "multiplyInteger-memory-arguments-slope": 1,
      "nullList-cpu-arguments": 60091,
      "nullList-memory-arguments": 32,
      "quotientInteger-cpu-arguments-constant": 196500,
      "quotientInteger-cpu-arguments-model-arguments-intercept": 453240,
      "quotientInteger-cpu-arguments-model-arguments-slope": 220,
      "quotientInteger-memory-arguments-intercept": 0,
      "quotientInteger-memory-arguments-minimum": 1,
      "quotientInteger-memory-arguments-slope": 1,
      "remainderInteger-cpu-arguments-constant": 196500,
      "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
      "remainderInteger-cpu-arguments-model-arguments-slope": 220,
      "remainderInteger-memory-arguments-intercept": 0,
      "remainderInteger-memory-arguments-minimum": 1,
      "remainderInteger-memory-arguments-slope": 1,
      "serialiseData-cpu-arguments-intercept": 1159724,
      "serialiseData-cpu-arguments-slope": 392670,
      "serialiseData-memory-arguments-intercept": 0,
      "serialiseData-memory-arguments-slope": 2,
      "sha2_256-cpu-arguments-intercept": 806990,
      "sha2_256-cpu-arguments-slope": 30482,
      "sha2_256-memory-arguments": 4,
      "sha3_256-cpu-arguments-intercept": 1927926,
      "sha3_256-cpu-arguments-slope": 82523,
      "sha3_256-memory-arguments": 4,
      "sliceByteString-cpu-arguments-intercept": 265318,
      "sliceByteString-cpu-arguments-slope": 0,
      "sliceByteString-memory-arguments-intercept": 4,
      "sliceByteString-memory-arguments-slope": 0,
      "sndPair-cpu-arguments": 85931,
      "sndPair-memory-arguments": 32,
      "subtractInteger-cpu-arguments-intercept": 205665,
      "subtractInteger-cpu-arguments-slope": 812,
      "subtractInteger-memory-arguments-intercept": 1,
      "subtractInteger-memory-arguments-slope": 1,
      "tailList-cpu-arguments": 41182,
      "tailList-memory-arguments": 32,
      "trace-cpu-arguments": 212342,
      "trace-memory-arguments": 32,
      "unBData-cpu-arguments": 31220,
      "unBData-memory-arguments": 32,
      "unConstrData-cpu-arguments": 32696,
      "unConstrData-memory-arguments": 32,
      "unIData-cpu-arguments": 43357,
      "unIData-memory-arguments": 32,
      "unListData-cpu-arguments": 32247,
      "unListData-memory-arguments": 32,
      "unMapData-cpu-arguments": 38314,
      "unMapData-memory-arguments": 32,
      "verifyEcdsaSecp256k1Signature-cpu-arguments": 35892428,
      "verifyEcdsaSecp256k1Signature-memory-arguments": 10,
      "verifyEd25519Signature-cpu-arguments-intercept": 57996947,
      "verifyEd25519Signature-cpu-arguments-slope": 18975,
      "verifyEd25519Signature-memory-arguments": 10,
      "verifySchnorrSecp256k1Signature-cpu-arguments-intercept": 38887044,
      "verifySchnorrSecp256k1Signature-cpu-arguments-slope": 32947,
      "verifySchnorrSecp256k1Signature-memory-arguments": 10
    }
  }
};

// src/credential.ts
function credentialToAddress(network, paymentCredential, stakeCredential) {
  if (stakeCredential) {
    return CML.BaseAddress.new(
      networkToId(network),
      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(paymentCredential.hash)
      ),
      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(stakeCredential.hash)
      )
    ).to_address().to_bech32(void 0);
  } else {
    return CML.EnterpriseAddress.new(
      networkToId(network),
      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(paymentCredential.hash)
      )
    ).to_address().to_bech32(void 0);
  }
}
function scriptHashToCredential(scriptHash) {
  return {
    type: "Script",
    hash: scriptHash
  };
}
function keyHashToCredential(keyHash) {
  return {
    type: "Key",
    hash: keyHash
  };
}
function paymentCredentialOf(address) {
  const { paymentCredential } = getAddressDetails(address);
  if (!paymentCredential) {
    throw new Error(
      "The specified address does not contain a payment credential."
    );
  }
  return paymentCredential;
}
function stakeCredentialOf(rewardAddress) {
  const { stakeCredential } = getAddressDetails(rewardAddress);
  if (!stakeCredential) {
    throw new Error(
      "The specified address does not contain a stake credential."
    );
  }
  return stakeCredential;
}

// src/datum.ts
function datumToHash(datum) {
  return CML.hash_plutus_data(CML.PlutusData.from_cbor_hex(datum)).to_hex();
}

// src/keys.ts
import { generateMnemonic } from "@lucid-evolution/bip39";
function generatePrivateKey() {
  return CML.PrivateKey.generate_ed25519().to_bech32();
}
function generateSeedPhrase() {
  return generateMnemonic(256);
}
function toPublicKey(privateKey) {
  return CML.PrivateKey.from_bech32(privateKey).to_public().to_bech32();
}

// src/label.ts
import { fromHex as fromHex3 } from "@lucid-evolution/core-utils";
import { crc8 } from "@lucid-evolution/crc8";
function toLabel(num) {
  if (num < 0 || num > 65535) {
    throw new Error(
      `Label ${num} out of range: min label 1 - max label 65535.`
    );
  }
  const numHex = num.toString(16).padStart(4, "0");
  return "0" + numHex + checksum(numHex) + "0";
}
function fromLabel(label) {
  if (label.length !== 8 || !(label[0] === "0" && label[7] === "0")) {
    return null;
  }
  const numHex = label.slice(1, 5);
  const num = parseInt(numHex, 16);
  const check = label.slice(5, 7);
  return check === checksum(numHex) ? num : null;
}
function checksum(num) {
  return crc8(fromHex3(num)).toString(16).padStart(2, "0");
}

// src/time.ts
import {
  SLOT_CONFIG_NETWORK,
  slotToBeginUnixTime,
  unixTimeToEnclosingSlot
} from "@lucid-evolution/plutus";
function unixTimeToSlot(network, unixTime) {
  return unixTimeToEnclosingSlot(unixTime, SLOT_CONFIG_NETWORK[network]);
}
function slotToUnixTime(network, slot) {
  return slotToBeginUnixTime(slot, SLOT_CONFIG_NETWORK[network]);
}

// src/utxo.ts
import * as CSL from "@emurgo/cardano-serialization-lib-nodejs";

// src/value.ts
import { fromHex as fromHex4, toHex as toHex3 } from "@lucid-evolution/core-utils";
function valueToAssets(value) {
  const assets = {};
  assets["lovelace"] = value.coin();
  if (value.has_multiassets()) {
    const ma = value.multi_asset();
    const multiAssets = ma.keys();
    for (let j = 0; j < multiAssets.len(); j++) {
      const policy = multiAssets.get(j);
      const policyAssets = ma.get_assets(policy);
      const assetNames = policyAssets.keys();
      for (let k = 0; k < assetNames.len(); k++) {
        const policyAsset = assetNames.get(k);
        const quantity = policyAssets.get(policyAsset);
        const unit = policy.to_hex() + policyAsset.to_js_value();
        assets[unit] = quantity;
      }
    }
  }
  return assets;
}
function assetsToValue(assets) {
  const multiAsset = CML.MultiAsset.new();
  const lovelace = assets["lovelace"] ? assets["lovelace"] : 0n;
  const units = Object.keys(assets);
  const policies = Array.from(
    new Set(
      units.filter((unit) => unit !== "lovelace").map((unit) => unit.slice(0, 56))
    )
  );
  for (const policy of policies) {
    const policyUnits = units.filter((unit) => unit.slice(0, 56) === policy);
    const assetsValue = CML.MapAssetNameToCoin.new();
    for (const unit of policyUnits) {
      assetsValue.insert(
        CML.AssetName.from_bytes(fromHex4(unit.slice(56))),
        BigInt(assets[unit])
      );
    }
    multiAsset.insert_assets(CML.ScriptHash.from_hex(policy), assetsValue);
  }
  return CML.Value.new(lovelace, multiAsset);
}
function fromUnit(unit) {
  const policyId = unit.slice(0, 56);
  const assetName = unit.slice(56) || null;
  const label = fromLabel(unit.slice(56, 64));
  const name = (() => {
    const hexName = Number.isInteger(label) ? unit.slice(64) : unit.slice(56);
    return hexName || null;
  })();
  return { policyId, assetName, name, label };
}
function toUnit(policyId, name, label) {
  const hexLabel = Number.isInteger(label) ? toLabel(label) : "";
  const n = name ? name : "";
  if ((n + hexLabel).length > 64) {
    throw new Error("Asset name size exceeds 32 bytes.");
  }
  if (policyId.length !== 56) {
    throw new Error(`Policy id invalid: ${policyId}.`);
  }
  return policyId + hexLabel + n;
}
function addAssets(...assets) {
  return assets.reduce((a, b) => {
    for (const k in b) {
      if (Object.hasOwn(b, k)) {
        a[k] = (a[k] || 0n) + b[k];
      }
    }
    return a;
  }, {});
}
async function getUniqueTokenName(utxo) {
  const id = fromHex4(utxo.txHash);
  const data = new Uint8Array([utxo.outputIndex, ...id]);
  const hash = new Uint8Array(await crypto.subtle.digest("SHA3-256", data));
  return toHex3(hash);
}

// src/utxo.ts
var utxoToTransactionOutput = (utxo) => {
  const buildDatum = (utxo2, builder) => {
    if (utxo2.datumHash)
      return builder.with_data(
        CML.DatumOption.new_hash(CML.DatumHash.from_hex(utxo2.datumHash))
      );
    if (utxo2.datum)
      return builder.with_data(
        CML.DatumOption.new_datum(CML.PlutusData.from_cbor_hex(utxo2.datum))
      );
    return builder;
  };
  const buildOutput = (utxo2) => {
    const builder = CML.TransactionOutputBuilder.new().with_address(
      CML.Address.from_bech32(utxo2.address)
    );
    return utxo2.scriptRef ? buildDatum(utxo2, builder).with_reference_script(toScriptRef(utxo2.scriptRef)).next() : buildDatum(utxo2, builder).next();
  };
  return buildOutput(utxo).with_value(assetsToValue(utxo.assets)).build().output();
};
var utxoToTransactionInput = (utxo) => {
  return CML.TransactionInput.new(
    CML.TransactionHash.from_hex(utxo.txHash),
    BigInt(utxo.outputIndex)
  );
};
var utxoToCore = (utxo) => {
  const out = utxoToTransactionOutput(utxo);
  const utxoCore = CML.TransactionUnspentOutput.new(
    utxoToTransactionInput(utxo),
    out
  );
  return utxoCore;
};
function utxosToCores(utxos) {
  const result = [];
  for (const utxo of utxos) {
    result.push(utxoToCore(utxo));
  }
  return result;
}
function coreToUtxo(coreUtxo) {
  const utxoCore = CSL.TransactionUnspentOutput.from_bytes(
    coreUtxo.to_cbor_bytes()
  );
  const utxo = {
    ...coreToOutRef(
      CML.TransactionInput.from_cbor_bytes(utxoCore.input().to_bytes())
    ),
    ...coreToTxOutput(
      CML.TransactionOutput.from_cbor_bytes(utxoCore.output().to_bytes())
    )
  };
  return utxo;
}
function coresToUtxos(utxos) {
  const result = [];
  for (let i = 0; i < utxos.length; i++) {
    result.push(coreToUtxo(utxos[i]));
  }
  return result;
}
function coreToOutRef(input) {
  return {
    txHash: input.transaction_id().to_hex(),
    outputIndex: parseInt(input.index().toString())
  };
}
function coresToOutRefs(inputs) {
  const result = [];
  for (let i = 0; i < inputs.length; i++) {
    result.push(coreToOutRef(inputs[i]));
  }
  return result;
}
function coreToTxOutput(output) {
  return {
    assets: valueToAssets(output.amount()),
    address: output.address().to_bech32(void 0),
    datumHash: output.datum()?.as_hash()?.to_hex(),
    datum: output.datum()?.as_datum()?.to_cbor_hex(),
    scriptRef: output.script_ref() && fromScriptRef(output.script_ref())
  };
}
function coresToTxOutputs(outputs) {
  let result = [];
  for (let i = 0; i < outputs.length; i++) {
    result.push(coreToTxOutput(outputs[i]));
  }
  return result;
}
var selectUTxOs = (utxos, totalAssets) => {
  const selectedUtxos = [];
  let isSelected = false;
  const assetsRequired = new Map(Object.entries(totalAssets));
  for (const utxo of utxos) {
    isSelected = false;
    for (const [unit, amount] of assetsRequired) {
      if (Object.hasOwn(utxo.assets, unit)) {
        const utxoAmount = utxo.assets[unit];
        if (utxoAmount >= amount) {
          assetsRequired.delete(unit);
        } else {
          assetsRequired.set(unit, amount - utxoAmount);
        }
        isSelected = true;
      }
    }
    if (isSelected) {
      selectedUtxos.push(utxo);
    }
    if (assetsRequired.size == 0) {
      break;
    }
  }
  if (assetsRequired.size > 0) return [];
  return selectedUtxos;
};
var sortUTxOs = (utxos, order = "LargestFirst") => {
  switch (order) {
    case "LargestFirst":
      return [...utxos].sort(largestFirst);
    case "SmallestFirst":
      return [...utxos].sort(smallestFirst);
  }
};
var largestFirst = (a, b) => {
  const lovelaceA = Number(a.assets["lovelace"]);
  const lovelaceB = Number(b.assets["lovelace"]);
  if (lovelaceA === lovelaceB) {
    return Object.keys(a.assets).length - Object.keys(b.assets).length;
  }
  return -1 * (lovelaceA - lovelaceB);
};
var smallestFirst = (a, b) => {
  const lovelaceA = Number(a.assets["lovelace"]);
  const lovelaceB = Number(b.assets["lovelace"]);
  if (lovelaceA == lovelaceB) {
    return Object.keys(a.assets).length - Object.keys(b.assets).length;
  }
  return lovelaceA - lovelaceB;
};
var isEqualUTxO = (self, that) => self.txHash === that.txHash && self.outputIndex === that.outputIndex;

// src/objects.ts
var stringify = (data) => JSON.stringify(
  data,
  (key, value) => typeof value === "bigint" ? value.toString() + "n" : value,
  2
);
export {
  PROTOCOL_PARAMETERS_DEFAULT,
  addAssets,
  addressFromHexOrBech32,
  applyDoubleCborEncoding,
  applyParamsToScript,
  assetsToValue,
  coreToOutRef,
  coreToTxOutput,
  coreToUtxo,
  coresToOutRefs,
  coresToTxOutputs,
  coresToUtxos,
  createCostModels,
  credentialToAddress,
  credentialToRewardAddress,
  datumToHash,
  fromLabel,
  fromScriptRef,
  fromUnit,
  generatePrivateKey,
  generateSeedPhrase,
  getAddressDetails,
  getUniqueTokenName,
  isEqualUTxO,
  keyHashToCredential,
  mintingPolicyToId,
  networkToId,
  parseCMLNative,
  paymentCredentialOf,
  scriptFromCMLNative,
  scriptFromNative,
  scriptHashToCredential,
  selectUTxOs,
  slotToUnixTime,
  sortUTxOs,
  stakeCredentialOf,
  stringify,
  toCMLNativeScript,
  toLabel,
  toPublicKey,
  toScriptRef,
  toUnit,
  unixTimeToSlot,
  utxoToCore,
  utxoToTransactionInput,
  utxoToTransactionOutput,
  utxosToCores,
  validatorToAddress,
  validatorToRewardAddress,
  validatorToScriptHash,
  valueToAssets
};
