"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ERROR_MESSAGE: () => ERROR_MESSAGE,
  Lucid: () => Lucid,
  RunTimeError: () => RunTimeError,
  TxBuilderError: () => TxBuilderError,
  TxSignerError: () => TxSignerError,
  TxSubmitError: () => TxSubmitError,
  makeRunTimeError: () => makeRunTimeError,
  makeTxBuilder: () => makeTxBuilder,
  makeTxSignBuilder: () => makeTxSignBuilder,
  signError: () => signError
});
module.exports = __toCommonJS(src_exports);

// src/core.ts
var import_effect = require("effect");
var CML = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var makeReturn = (program) => {
  return {
    unsafeRun: () => import_effect.Effect.runPromise(program),
    safeRun: () => import_effect.Effect.runPromise(import_effect.Effect.either(program)),
    program: () => program
  };
};

// src/lucid-evolution/utils.ts
var import_utils = require("@lucid-evolution/utils");
var import_plutus = require("@lucid-evolution/plutus");
var datumOf = async (provider, utxo, type) => {
  if (!utxo.datum) {
    if (!utxo.datumHash) {
      throw new Error("This UTxO does not have a datum hash.");
    }
    utxo.datum = await provider.getDatum(utxo.datumHash);
  }
  return import_plutus.Data.from(utxo.datum, type);
};
var metadataOf = async (provider, unit) => {
  const { policyId, name, label } = (0, import_utils.fromUnit)(unit);
  switch (label) {
    case 222:
    case 333:
    case 444: {
      const utxo = await provider.getUtxoByUnit((0, import_utils.toUnit)(policyId, name, 100));
      const metadata = await datumOf(provider, utxo);
      return import_plutus.Data.toJson(metadata.fields[0]);
    }
    default:
      throw new Error("No variant matched.");
  }
};

// src/lucid-evolution/LucidEvolution.ts
var import_utils16 = require("@lucid-evolution/utils");

// src/tx-builder/internal/Collect.ts
var import_effect4 = require("effect");
var import_plutus2 = require("@lucid-evolution/plutus");
var import_utils4 = require("@lucid-evolution/utils");

// src/Errors.ts
var import_effect2 = require("effect");
var ERROR_MESSAGE = {
  MULTIPLE_POLICIES: "Only one policy id allowed. You can chain multiple mintAssets functions together if you need to mint assets with different policy ids. ",
  EMPTY_UTXO: "UTxO array is empty. If a Tx has been recently submitted, consider waiting for chain sync",
  MISSING_WALLET: "Please ensure that it has been properly configured and initialized",
  MISSING_REDEEMER: "redeemer can not be undefined"
};
var TxBuilderError = class extends import_effect2.Data.TaggedError("TxBuilderError") {
};
var TxSignerError = class extends import_effect2.Data.TaggedError("TxSignerError") {
};
var TxSubmitError = class extends import_effect2.Data.TaggedError("TxSubmitError") {
};
var RunTimeError = class extends import_effect2.Data.TaggedError("RunTimeError") {
};
var makeRunTimeError = (error) => {
  return new RunTimeError({
    message: JSON.stringify(String(error))
  });
};

// src/tx-builder/internal/Collect.ts
var CML2 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);

// src/tx-builder/internal/TxUtils.ts
var import_effect3 = require("effect");
var import_utils2 = require("@lucid-evolution/utils");
var import_utils3 = require("@lucid-evolution/utils");
var toDatumOption = (outputDatum) => {
  switch (outputDatum.kind) {
    case "hash":
      return CML.DatumOption.new_hash(
        CML.DatumHash.from_hex(outputDatum.value)
      );
    case "asHash": {
      const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
      return CML.DatumOption.new_hash(CML.hash_plutus_data(plutusData));
    }
    case "inline": {
      const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
      return CML.DatumOption.new_datum(plutusData);
    }
  }
};
var toCMLAddress = (address, lucidConfig) => import_effect3.Effect.gen(function* ($) {
  const { type } = yield* validateAddressDetails(address, lucidConfig);
  return type === "Byron" ? CML.ByronAddress.from_base58(address).to_address() : CML.Address.from_bech32(address);
});
var toV1 = (script) => CML.PlutusScript.from_v1(CML.PlutusV1Script.from_cbor_hex(script));
var toV2 = (script) => {
  const v2 = CML.PlutusV2Script.from_cbor_hex(script);
  return CML.PlutusScript.from_v2(v2);
};
var toPartial = (script, redeemer) => CML.PartialPlutusWitness.new(
  CML.PlutusScriptWitness.new_script(script),
  CML.PlutusData.from_cbor_hex(redeemer)
);
var validateAddressDetails = (address, lucidConfig) => import_effect3.Effect.gen(function* ($) {
  const addressDetails = yield* $(
    import_effect3.Effect.try({
      try: () => (0, import_utils3.getAddressDetails)(address),
      catch: (error) => new TxBuilderError({
        cause: "Address",
        message: String(error)
      })
    })
  );
  const actualNetworkId = (0, import_utils2.networkToId)(lucidConfig.network);
  if (addressDetails.networkId !== actualNetworkId)
    yield* new TxBuilderError({
      cause: "InvalidNetwork",
      message: `Invalid address: ${address}, Expected address with network id ${actualNetworkId}, current network ${lucidConfig.network}`
    });
  return addressDetails;
});

// src/tx-builder/internal/Collect.ts
var import_utils5 = require("@lucid-evolution/utils");
var collectError = (cause, message) => new TxBuilderError({ cause, module: "Collect", message });
var collectFromUTxO = (config, utxos, redeemer) => import_effect4.Effect.gen(function* ($) {
  if (utxos.length === 0)
    yield* $(collectError("EmptyUTXO", ERROR_MESSAGE.EMPTY_UTXO));
  for (const utxo of utxos) {
    if (utxo.datumHash && !utxo.datum) {
      const data = yield* $(
        import_effect4.Effect.tryPromise({
          try: () => datumOf(config.lucidConfig.provider, utxo),
          catch: (error) => collectError("Datum", String(error))
        })
      );
      utxo.datum = import_plutus2.Data.to(data);
    }
    const coreUtxo = (0, import_utils4.utxoToCore)(utxo);
    config.collectedInputs.push(utxo);
    const input = CML2.SingleInputBuilder.from_transaction_unspent_output(coreUtxo);
    const credential = (0, import_utils5.paymentCredentialOf)(utxo.address);
    if (credential.type == "Script") {
      const script = yield* $(
        import_effect4.Effect.fromNullable(config.scripts.get(credential.hash)),
        import_effect4.Effect.orElseFail(
          () => collectError(
            "MissingScript",
            `No script found, script hash: ${credential.hash}, consider using attach modules`
          )
        )
      );
      switch (script.type) {
        case "Native":
          config.txBuilder.add_input(
            input.native_script(
              CML2.NativeScript.from_cbor_hex(script.script),
              CML2.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        case "PlutusV1": {
          const red = yield* $(
            import_effect4.Effect.fromNullable(redeemer),
            import_effect4.Effect.orElseFail(
              () => collectError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          config.txBuilder.add_input(
            input.plutus_script(
              toPartial(toV1(script.script), red),
              CML2.Ed25519KeyHashList.new(),
              CML2.PlutusData.from_cbor_hex(utxo.datum)
            )
          );
          break;
        }
        case "PlutusV2": {
          const v2 = toV2(script.script);
          const red = yield* $(
            import_effect4.Effect.fromNullable(redeemer),
            import_effect4.Effect.orElseFail(
              () => collectError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          const partial = toPartial(v2, red);
          config.txBuilder.add_input(
            //TODO: Test with DatumHash
            input.plutus_script_inline_datum(
              partial,
              CML2.Ed25519KeyHashList.new()
            )
          );
          break;
        }
      }
    } else {
      config.txBuilder.add_input(input.payment_key());
    }
  }
});

// src/tx-builder/internal/Read.ts
var import_effect5 = require("effect");
var import_plutus3 = require("@lucid-evolution/plutus");
var import_utils7 = require("@lucid-evolution/utils");
var readError = (cause, message) => new TxBuilderError({ cause, module: "Read", message });
var readFrom = (config, utxos) => import_effect5.Effect.gen(function* () {
  if (utxos.length === 0)
    yield* readError("EmptyUTXO", ERROR_MESSAGE.EMPTY_UTXO);
  for (const utxo of utxos) {
    if (utxo.datumHash) {
      const data = yield* import_effect5.Effect.tryPromise({
        try: () => datumOf(config.lucidConfig.provider, utxo),
        catch: (error) => readError("Datum", String(error))
      });
      utxo.datum = import_plutus3.Data.to(data);
    }
    const coreUtxo = (0, import_utils7.utxoToCore)(utxo);
    config.readInputs.push(utxo);
    config.txBuilder.add_reference_input(coreUtxo);
  }
});

// src/tx-builder/internal/Attach.ts
var import_utils9 = require("@lucid-evolution/utils");
var attachScript = ({
  type,
  script
}) => {
  switch (type) {
    case "Native":
      return {
        key: CML.NativeScript.from_cbor_hex(script).hash().to_hex(),
        value: { type, script }
      };
    case "PlutusV1":
      return {
        key: CML.PlutusV1Script.from_cbor_hex((0, import_utils9.applyDoubleCborEncoding)(script)).hash().to_hex(),
        value: { type, script: (0, import_utils9.applyDoubleCborEncoding)(script) }
      };
    case "PlutusV2":
      return {
        key: CML.PlutusV2Script.from_cbor_hex((0, import_utils9.applyDoubleCborEncoding)(script)).hash().to_hex(),
        value: { type, script: (0, import_utils9.applyDoubleCborEncoding)(script) }
      };
  }
};
var attachSpendingValidator = (spendingValidator) => attachScript(spendingValidator);
var attachMintingPolicy = (mintingPolicy) => attachScript(mintingPolicy);
var attachCertificateValidator = (certValidator) => attachScript(certValidator);
var attachWithdrawalValidator = (withdrawalValidator) => attachScript(withdrawalValidator);

// src/tx-builder/internal/Pay.ts
var import_effect6 = require("effect");
var import_utils10 = require("@lucid-evolution/utils");
var payError = (cause, message) => new TxBuilderError({ cause, module: "Pay", message });
var payToAddress = (config, address, assets) => import_effect6.Effect.gen(function* () {
  const outputBuilder = CML.TransactionOutputBuilder.new().with_address(yield* toCMLAddress(address, config.lucidConfig)).next();
  if (Object.keys(assets).length == 0)
    yield* payError(
      "EmptyAssets",
      "Attempting to pay to an address with an empty assets object"
    );
  if (assets["lovelace"]) {
    const outputResult = outputBuilder.with_value((0, import_utils10.assetsToValue)(assets)).build();
    config.totalOutputAssets = (0, import_utils10.addAssets)(
      config.totalOutputAssets,
      (0, import_utils10.valueToAssets)(outputResult.output().amount())
    );
    config.txBuilder.add_output(outputResult);
  } else {
    const outputResult = outputBuilder.with_asset_and_min_required_coin(
      (0, import_utils10.assetsToValue)(assets).multi_asset(),
      config.lucidConfig.protocolParameters.coinsPerUtxoByte
    ).build();
    config.totalOutputAssets = (0, import_utils10.addAssets)(
      config.totalOutputAssets,
      (0, import_utils10.valueToAssets)(outputResult.output().amount())
    );
    config.txBuilder.add_output(outputResult);
  }
});
var payToAddressWithData = (config, address, outputDatum, assets, scriptRef) => import_effect6.Effect.gen(function* () {
  const outputBuilder = buildBaseOutput(address, outputDatum, scriptRef);
  if (assets) {
    if (Object.keys(assets).length == 0)
      yield* payError(
        "EmptyAssets",
        "Attempting to pay to an address with an empty assets object"
      );
    if (assets["lovelace"]) {
      const outputResult = outputBuilder.with_value((0, import_utils10.assetsToValue)(assets)).build();
      config.totalOutputAssets = (0, import_utils10.addAssets)(
        config.totalOutputAssets,
        (0, import_utils10.valueToAssets)(outputResult.output().amount())
      );
      config.txBuilder.add_output(outputResult);
    } else {
      const outputResult = outputBuilder.with_asset_and_min_required_coin(
        (0, import_utils10.assetsToValue)(assets).multi_asset(),
        config.lucidConfig.protocolParameters.coinsPerUtxoByte
      ).build();
      config.totalOutputAssets = (0, import_utils10.addAssets)(
        config.totalOutputAssets,
        (0, import_utils10.valueToAssets)(outputResult.output().amount())
      );
      config.txBuilder.add_output(outputResult);
    }
  } else {
    const outputResult = outputBuilder.with_asset_and_min_required_coin(
      CML.MultiAsset.new(),
      config.lucidConfig.protocolParameters.coinsPerUtxoByte
    ).build();
    config.totalOutputAssets = (0, import_utils10.addAssets)(
      config.totalOutputAssets,
      (0, import_utils10.valueToAssets)(outputResult.output().amount())
    );
    config.txBuilder.add_output(outputResult);
  }
});
var payToContract = (config, address, outputDatum, assets, scriptRef) => import_effect6.Effect.gen(function* () {
  if (!outputDatum.value)
    yield* payError(
      "Datum",
      "No datum set. Script output becomes unspendable without datum."
    );
  return yield* payToAddressWithData(
    config,
    address,
    outputDatum,
    assets,
    scriptRef
  );
});
var buildBaseOutput = (address, outputDatum, scriptRef) => {
  const baseBuilder = CML.TransactionOutputBuilder.new().with_address(CML.Address.from_bech32(address)).with_data(toDatumOption(outputDatum));
  return scriptRef ? baseBuilder.with_reference_script((0, import_utils10.toScriptRef)(scriptRef)).next() : baseBuilder.next();
};

// src/tx-builder/internal/Mint.ts
var import_effect7 = require("effect");
var import_core_utils = require("@lucid-evolution/core-utils");
var CML3 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var import_utils11 = require("@lucid-evolution/utils");
var mintError = (cause, message) => new TxBuilderError({ cause, module: "Mint", message });
var mintAssets = (config, assets, redeemer) => import_effect7.Effect.gen(function* () {
  config.mintedAssets = (0, import_utils11.addAssets)(config.mintedAssets, assets);
  const units = Object.keys(assets);
  const policyId = units[0].slice(0, 56);
  const mintAssets2 = CML3.MapAssetNameToNonZeroInt64.new();
  for (const unit of units) {
    if (unit.slice(0, 56) !== policyId) {
      yield* mintError("MultiplePolicies", ERROR_MESSAGE.MULTIPLE_POLICIES);
    }
    mintAssets2.insert(
      CML3.AssetName.from_bytes((0, import_core_utils.fromHex)(unit.slice(56))),
      assets[unit]
    );
  }
  const mintBuilder = CML3.SingleMintBuilder.new(mintAssets2);
  const policy = yield* (0, import_effect7.pipe)(
    import_effect7.Effect.fromNullable(config.scripts.get(policyId)),
    import_effect7.Effect.orElseFail(
      () => mintError("MissingPolicy", `No policy found, policy id: ${policyId}`)
    )
  );
  switch (policy.type) {
    case "Native":
      config.txBuilder.add_mint(
        mintBuilder.native_script(
          CML3.NativeScript.from_cbor_hex(policy.script),
          CML3.NativeScriptWitnessInfo.assume_signature_count()
        )
      );
      break;
    case "PlutusV1": {
      const red = yield* (0, import_effect7.pipe)(
        import_effect7.Effect.fromNullable(redeemer),
        import_effect7.Effect.orElseFail(
          () => mintError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV1(policy.script), red),
          CML3.Ed25519KeyHashList.new()
        )
      );
      break;
    }
    case "PlutusV2": {
      const red = yield* (0, import_effect7.pipe)(
        import_effect7.Effect.fromNullable(redeemer),
        import_effect7.Effect.orElseFail(
          () => mintError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV2(policy.script), red),
          CML3.Ed25519KeyHashList.new()
        )
      );
      break;
    }
  }
});

// src/tx-builder/internal/Interval.ts
var import_effect8 = require("effect");
var import_utils12 = require("@lucid-evolution/utils");
var validFrom = (config, unixTime) => import_effect8.Effect.gen(function* () {
  const slot = (0, import_utils12.unixTimeToSlot)(config.lucidConfig.network, unixTime);
  config.txBuilder.set_validity_start_interval(BigInt(slot));
});
var validTo = (config, unixTime) => import_effect8.Effect.gen(function* () {
  const slot = (0, import_utils12.unixTimeToSlot)(config.lucidConfig.network, unixTime);
  config.txBuilder.set_ttl(BigInt(slot));
});

// src/tx-builder/internal/Signer.ts
var import_effect9 = require("effect");
var CML4 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var addSignerError = (cause, message) => new TxBuilderError({ cause, module: "Signer", message });
var addSigner = (config, address) => import_effect9.Effect.gen(function* () {
  const addressDetails = yield* validateAddressDetails(
    address,
    config.lucidConfig
  );
  if (!addressDetails.paymentCredential && !addressDetails.stakeCredential)
    yield* addSignerError(
      "NotFound",
      "undefined paymentCredential and stakeCredential"
    );
  const credential = addressDetails.type === "Reward" ? addressDetails.stakeCredential : addressDetails.paymentCredential;
  if (credential.type === "Script")
    yield* addSignerError(
      "InvalidCredential",
      "Only key hashes are allowed as signers."
    );
  return credential.hash;
}).pipe(import_effect9.Effect.flatMap((keyHash) => addSignerKey(config, keyHash)));
var addSignerKey = (config, keyHash) => import_effect9.Effect.gen(function* () {
  config.txBuilder.add_required_signer(CML4.Ed25519KeyHash.from_hex(keyHash));
});

// src/tx-builder/internal/Stake.ts
var import_effect10 = require("effect");
var CML5 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var stakeError = (cause, message) => new TxBuilderError({ cause, module: "Stake", message });
var registerStake = (config, rewardAddress) => import_effect10.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect10.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect10.Effect.andThen(
      (address) => address.type !== "Reward" ? stakeError("InvalidCredential", "Address type must be Reward type.") : import_effect10.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect10.Effect.orElseFail(() => stakeError("MissingStakeCredential"))
  );
  const credential = stakeCredential.type === "Key" ? CML5.Credential.new_pub_key(
    CML5.Ed25519KeyHash.from_hex(stakeCredential.hash)
  ) : CML5.Credential.new_script(
    CML5.ScriptHash.from_hex(stakeCredential.hash)
  );
  const certBuilder = CML5.SingleCertificateBuilder.new(
    CML5.Certificate.new_stake_registration(credential)
  );
  config.txBuilder.add_cert(certBuilder.skip_witness());
});
var deRegisterStake = (config, rewardAddress, redeemer) => import_effect10.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect10.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect10.Effect.andThen(
      (address) => address.type !== "Reward" ? stakeError("InvalidCredential", "Address type must be Reward type.") : import_effect10.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect10.Effect.orElseFail(() => stakeError("MissingStakeCredential"))
  );
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML5.Credential.new_pub_key(
        CML5.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML5.SingleCertificateBuilder.new(
        CML5.Certificate.new_stake_deregistration(credential)
      );
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML5.Credential.new_script(
        CML5.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML5.SingleCertificateBuilder.new(
        CML5.Certificate.new_stake_deregistration(credential)
      );
      const script = yield* (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect10.Effect.orElseFail(
          () => stakeError(
            "MissingScript",
            `No script found, script hash: ${stakeCredential.hash}, consider using attach modules`
          )
        )
      );
      const red = yield* (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(redeemer),
        import_effect10.Effect.orElseFail(
          () => stakeError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          yield* stakeError("NotFound");
          break;
        }
      }
    }
  }
});
var withdraw = (config, rewardAddress, amount, redeemer) => import_effect10.Effect.gen(function* ($) {
  const addressDetails = yield* (0, import_effect10.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect10.Effect.andThen(
      (address) => address.type !== "Reward" ? stakeError("InvalidCredential", "Address type must be Reward type.") : import_effect10.Effect.succeed(address)
    )
  );
  const withdrawBuilder = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(
      CML5.RewardAddress.from_address(CML5.Address.from_bech32(rewardAddress))
    ),
    import_effect10.Effect.orElseFail(() => stakeError("MissingStakeCredential")),
    import_effect10.Effect.andThen(
      (address) => CML5.SingleWithdrawalBuilder.new(address, amount)
    )
  );
  const stakeCredential = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect10.Effect.orElseFail(() => stakeError("MissingStakeCredential"))
  );
  switch (stakeCredential.type) {
    case "Key": {
      config.txBuilder.add_withdrawal(withdrawBuilder.payment_key());
      break;
    }
    case "Script": {
      const script = yield* (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect10.Effect.orElseFail(
          () => stakeError(
            "MissingScript",
            `No script found, script hash: ${stakeCredential.hash}, consider using attach modules`
          )
        )
      );
      const red = yield* (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(redeemer),
        import_effect10.Effect.orElseFail(
          () => stakeError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          yield* stakeError("NotFound");
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Pool.ts
var import_effect11 = require("effect");
var CML6 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var import_core_utils2 = require("@lucid-evolution/core-utils");
var poolError = (cause, message) => new TxBuilderError({ cause, module: "Pool", message });
var delegateTo = (config, rewardAddress, poolId, redeemer) => import_effect11.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect11.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect11.Effect.andThen(
      (address) => address.type !== "Reward" ? poolError("InvalidCredential", "Address type must be Reward type.") : import_effect11.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect11.pipe)(
    import_effect11.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect11.Effect.orElseFail(() => poolError("MissingStakeCredential"))
  );
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML6.Credential.new_pub_key(
        CML6.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML6.SingleCertificateBuilder.new(
        CML6.Certificate.new_stake_delegation(
          credential,
          CML6.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML6.Credential.new_script(
        CML6.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML6.SingleCertificateBuilder.new(
        CML6.Certificate.new_stake_delegation(
          credential,
          CML6.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      const script = yield* (0, import_effect11.pipe)(
        import_effect11.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect11.Effect.orElseFail(
          () => poolError(
            "MissingScript",
            `No script found, script hash: ${stakeCredential.hash}, consider using attach modules`
          )
        )
      );
      const red = yield* (0, import_effect11.pipe)(
        import_effect11.Effect.fromNullable(redeemer),
        import_effect11.Effect.orElseFail(
          () => poolError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          yield* poolError("NotFound");
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Metadata.ts
var import_effect12 = require("effect");
var S = __toESM(require("@effect/schema/Schema"), 1);
var import_core_utils3 = require("@lucid-evolution/core-utils");
var attachMetadata = (config, label, metadata) => import_effect12.Effect.gen(function* () {
  const auxiliaryData = CML.AuxiliaryData.new();
  const meta = CML.Metadata.new();
  meta.set(
    BigInt(label),
    CML.TransactionMetadatum.from_json(
      JSON.stringify(toCardanoMetadata(metadata))
    )
  );
  auxiliaryData.add_metadata(meta);
  config.txBuilder.add_auxiliary_data(auxiliaryData);
  auxiliaryData.free();
  meta.free();
});
var TextSchema = S.String.pipe(S.maxLength(64));
var TransactionMetadataSchema = S.Union(
  TextSchema,
  S.Number,
  S.Uint8ArrayFromSelf,
  S.Array(S.suspend(() => TransactionMetadataSchema)),
  S.Record(
    S.String,
    S.suspend(() => TransactionMetadataSchema)
  )
);
var toCardanoMetadata = (json) => {
  const d = S.asserts(TransactionMetadataSchema)(json);
  if (S.is(TextSchema)(json)) {
    return { string: json };
  }
  if (typeof json === "number") {
    return { int: json };
  }
  if (json instanceof Uint8Array) {
    return { bytes: (0, import_core_utils3.toHex)(json) };
  }
  if (Array.isArray(json)) {
    return { list: json.map((value) => toCardanoMetadata(value)) };
  }
  if (typeof json === "object" && json !== null) {
    const mapEntries = Object.entries(json).map(([k, v]) => ({
      k: toCardanoMetadata(k),
      v: toCardanoMetadata(v)
    }));
    return { map: mapEntries };
  }
  throw new Error("Unsupported type");
};

// src/tx-builder/internal/CompleteTxBuilder.ts
var import_effect16 = require("effect");
var UPLC = __toESM(require("@lucid-evolution/uplc"), 1);

// src/tx-sign-builder/internal/CompleteTxSigner.ts
var import_effect14 = require("effect");

// src/tx-submit/TxSubmit.ts
var import_effect13 = require("effect");
var submitError = (cause, message) => new TxSubmitError({ cause, module: "Submit", message });
var makeSubmit = (wallet, txSigned) => {
  const submit = import_effect13.Effect.tryPromise({
    try: () => wallet.submitTx(txSigned.to_cbor_hex()),
    catch: (error) => submitError("SubmitError", String(error))
  });
  return {
    submit: () => makeReturn(submit).unsafeRun(),
    submitProgram: () => makeReturn(submit).program(),
    submitSafe: () => makeReturn(submit).safeRun(),
    toCBOR: () => txSigned.to_cbor_hex(),
    toHash: () => CML.hash_transaction(txSigned.body()).to_hex()
  };
};

// src/tx-sign-builder/internal/CompleteTxSigner.ts
var import_utils13 = require("@lucid-evolution/utils");
var completeTxSigner = (config) => import_effect14.Effect.gen(function* () {
  yield* import_effect14.Effect.all(config.programs, { concurrency: "unbounded" });
  config.witnessSetBuilder.add_existing(config.txComplete.witness_set());
  const txWitnessSet = config.witnessSetBuilder.build();
  const signedTx = CML.Transaction.new(
    config.txComplete.body(),
    txWitnessSet,
    true,
    config.txComplete.auxiliary_data()
  );
  const wallet = yield* (0, import_effect14.pipe)(
    import_effect14.Effect.fromNullable(config.lucidConfig.wallet),
    import_effect14.Effect.orElseFail(
      () => signError("MissingWallet", ERROR_MESSAGE.MISSING_WALLET)
    )
  );
  return makeSubmit(wallet, signedTx);
}).pipe(
  import_effect14.Effect.catchAllDefect(
    (e) => new RunTimeError({ message: (0, import_utils13.stringify)(String(e)) })
  )
);

// src/tx-sign-builder/internal/Sign.ts
var import_effect15 = require("effect");
var signError2 = (cause, message) => new TxSignerError({ cause, module: "Sign", message });
var withWallet = (config) => import_effect15.Effect.gen(function* () {
  const wallet = yield* (0, import_effect15.pipe)(
    import_effect15.Effect.fromNullable(config.lucidConfig.wallet),
    import_effect15.Effect.orElseFail(
      () => signError2("MissingWallet", ERROR_MESSAGE.MISSING_WALLET)
    )
  );
  const witnesses = yield* import_effect15.Effect.tryPromise({
    try: () => wallet.signTx(config.txComplete),
    catch: (error) => signError2("Signature", String(error))
  });
  config.witnessSetBuilder.add_existing(witnesses);
});
var withPrivateKey = (config, privateKey) => import_effect15.Effect.gen(function* () {
  const priv = CML.PrivateKey.from_bech32(privateKey);
  const witness = CML.make_vkey_witness(
    CML.hash_transaction(config.txComplete.body()),
    priv
  );
  config.witnessSetBuilder.add_vkey(witness);
});

// src/tx-sign-builder/TxSignBuilder.ts
var signError = (cause, message) => new TxSignerError({ cause, module: "Sign", message });
var makeTxSignBuilder = (lucidConfig, tx) => {
  const redeemers = tx.witness_set().redeemers();
  const exUnits = { cpu: 0, mem: 0 };
  if (redeemers) {
    for (let i = 0; i < redeemers.as_arr_legacy_redeemer().len(); i++) {
      const redeemer = redeemers.as_arr_legacy_redeemer().get(i);
      exUnits.cpu += parseInt(redeemer.ex_units().steps().toString());
      exUnits.mem += parseInt(redeemer.ex_units().mem().toString());
    }
  }
  const config = {
    txComplete: tx,
    witnessSetBuilder: CML.TransactionWitnessSetBuilder.new(),
    programs: [],
    lucidConfig,
    fee: parseInt(tx.body().fee().toString()),
    exUnits
  };
  const txSignBuilder = {
    sign: {
      withWallet: () => {
        const program = withWallet(config);
        config.programs.push(program);
        return txSignBuilder;
      },
      withPrivateKey: (privateKey) => {
        const program = withPrivateKey(config, privateKey);
        config.programs.push(program);
        return txSignBuilder;
      }
    },
    complete: () => makeReturn(completeTxSigner(config)).unsafeRun(),
    completeProgram: () => makeReturn(completeTxSigner(config)).program(),
    completeSafe: () => makeReturn(completeTxSigner(config)).safeRun()
  };
  return txSignBuilder;
};

// src/tx-builder/internal/CompleteTxBuilder.ts
var import_utils14 = require("@lucid-evolution/utils");
var import_plutus4 = require("@lucid-evolution/plutus");
var completeTxError = (cause, message) => new TxBuilderError({ cause, module: "Complete", message });
var getWalletInfo = (config) => import_effect16.Effect.gen(function* () {
  const wallet = yield* (0, import_effect16.pipe)(
    import_effect16.Effect.fromNullable(config.lucidConfig.wallet),
    import_effect16.Effect.orElseFail(
      () => completeTxError("MissingWallet", ERROR_MESSAGE.MISSING_WALLET)
    )
  );
  const address = yield* import_effect16.Effect.promise(() => wallet.address());
  const inputs = yield* (0, import_effect16.pipe)(
    import_effect16.Effect.tryPromise({
      try: () => wallet.getUtxos(),
      catch: (error) => completeTxError("Provider", String(error))
    })
  );
  const walletInputs = import_effect16.Array.isEmptyArray(config.walletInputs) ? inputs : config.walletInputs;
  return {
    wallet,
    address,
    inputs: walletInputs
  };
});
var complete = (config, options = { coinSelection: true, localUPLCEval: true }) => import_effect16.Effect.gen(function* () {
  yield* import_effect16.Effect.all(config.programs, { concurrency: "unbounded" });
  const walletInfo = yield* getWalletInfo(config);
  if (config.scripts.size > 0) {
    const collateralInput = yield* findCollateral(
      config.lucidConfig.protocolParameters.coinsPerUtxoByte,
      walletInfo.inputs
    );
    setCollateral(config, collateralInput, walletInfo.address);
  }
  const availableInputs = import_effect16.Array.differenceWith(import_utils14.isEqualUTxO)(
    walletInfo.inputs,
    config.collectedInputs
  );
  const inputsToAdd = options.coinSelection !== false ? yield* coinSelection(config, availableInputs) : [];
  for (const utxo of inputsToAdd) {
    const input = CML.SingleInputBuilder.from_transaction_unspent_output(
      (0, import_utils14.utxoToCore)(utxo)
    ).payment_key();
    config.txBuilder.add_input(input);
  }
  config.consumedInputs = [...config.collectedInputs, ...inputsToAdd];
  const txRedeemerBuilder = yield* import_effect16.Effect.try({
    try: () => config.txBuilder.build_for_evaluation(
      0,
      CML.Address.from_bech32(walletInfo.address)
    ),
    catch: (error) => completeTxError("BuildEvaluation", String(error))
  });
  if (options.localUPLCEval !== false && txRedeemerBuilder.draft_tx().witness_set().redeemers()) {
    applyUPLCEval(
      yield* evalTransaction(config, txRedeemerBuilder, walletInfo.inputs),
      config.txBuilder
    );
  }
  config.txBuilder.add_change_if_needed(
    CML.Address.from_bech32(walletInfo.address),
    true
  );
  const tx = yield* import_effect16.Effect.try({
    try: () => config.txBuilder.build(
      CML.ChangeSelectionAlgo.Default,
      CML.Address.from_bech32(walletInfo.address)
    ).build_unchecked(),
    catch: (error) => completeTxError("Build", String(error))
  });
  const derivedInputs = deriveInputsFromTransaction(tx);
  const derivedWalletInputs = derivedInputs.filter(
    (utxo) => utxo.address === walletInfo.address
  );
  const updatedWalletInputs = (0, import_effect16.pipe)(
    import_effect16.Array.differenceWith(import_utils14.isEqualUTxO)(
      walletInfo.inputs,
      config.consumedInputs
    ),
    (availableWalletInputs) => [
      ...derivedWalletInputs,
      ...availableWalletInputs
    ]
  );
  return import_effect16.Tuple.make(
    updatedWalletInputs,
    derivedInputs,
    makeTxSignBuilder(config.lucidConfig, tx)
  );
}).pipe(
  import_effect16.Effect.catchAllDefect(
    (e) => new RunTimeError({ message: (0, import_utils14.stringify)(String(e)) })
  )
);
var applyUPLCEval = (uplcEval, txbuilder) => {
  for (const bytes of uplcEval) {
    const redeemer = CML.LegacyRedeemer.from_cbor_bytes(bytes);
    const exUnits = CML.ExUnits.new(
      redeemer.ex_units().mem(),
      redeemer.ex_units().steps()
    );
    txbuilder.set_exunits(
      CML.RedeemerWitnessKey.new(redeemer.tag(), redeemer.index()),
      exUnits
    );
  }
};
var setRedeemerstoZero = (tx) => {
  const redeemers = tx.witness_set().redeemers();
  if (redeemers) {
    const redeemerList = CML.LegacyRedeemerList.new();
    for (let i = 0; i < redeemers.as_arr_legacy_redeemer().len(); i++) {
      const redeemer = redeemers.as_arr_legacy_redeemer().get(i);
      const dummyRedeemer = CML.LegacyRedeemer.new(
        redeemer.tag(),
        redeemer.index(),
        redeemer.data(),
        CML.ExUnits.new(0n, 0n)
      );
      redeemerList.add(dummyRedeemer);
    }
    const dummyWitnessSet = tx.witness_set();
    dummyWitnessSet.set_redeemers(
      CML.Redeemers.new_arr_legacy_redeemer(redeemerList)
    );
    return CML.Transaction.new(
      tx.body(),
      dummyWitnessSet,
      true,
      tx.auxiliary_data()
    );
  }
};
var setCollateral = (config, collateralInputs, changeAddress) => {
  for (const utxo of collateralInputs) {
    const collateralInput = CML.SingleInputBuilder.from_transaction_unspent_output(
      (0, import_utils14.utxoToCore)(utxo)
    ).payment_key();
    config.txBuilder.add_collateral(collateralInput);
  }
  const returnassets = (0, import_effect16.pipe)(
    sumAssetsFromInputs(collateralInputs),
    import_effect16.Record.union({ lovelace: -5000000n }, import_effect16.BigInt.sum)
  );
  const collateralOutputBuilder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress)
  );
  config.txBuilder.set_collateral_return(
    collateralOutputBuilder.next().with_value((0, import_utils14.assetsToValue)(returnassets)).build().output()
  );
};
var findCollateral = (coinsPerUtxoByte, inputs) => import_effect16.Effect.gen(function* () {
  const minLovelaceChangeAddress = {
    lovelace: calculateMinLovelace(coinsPerUtxoByte)
  };
  const collateralLovelace = { lovelace: 5000000n };
  const requiredAssets = import_effect16.Record.union(
    minLovelaceChangeAddress,
    collateralLovelace,
    import_effect16.BigInt.sum
  );
  const selected = recursive(
    (0, import_utils14.sortUTxOs)(inputs),
    collateralLovelace,
    coinsPerUtxoByte
  );
  if (import_effect16.Array.isEmptyArray(selected))
    yield* completeTxError(
      "MissingCollateral",
      `Your wallet does not have enough funds to cover the required 5 ADA collateral.`
    );
  if (selected.length > 3)
    yield* completeTxError(
      "MissingCollateral",
      `Selected ${selected.length} inputs as collateral, but max collateral inputs is 3 to cover the 5 ADA collateral ${(0, import_utils14.stringify)(selected)}`
    );
  return selected;
});
var coinSelection = (config, availableInputs) => import_effect16.Effect.gen(function* () {
  const estimatedFee = { lovelace: 2000000n };
  const negatedMintedAssets = negateAssets(config.mintedAssets);
  const negatedCollectedAssets = negateAssets(
    sumAssetsFromInputs(config.collectedInputs)
  );
  const assetsDelta = (0, import_effect16.pipe)(
    config.totalOutputAssets,
    import_effect16.Record.union(estimatedFee, import_effect16.BigInt.sum),
    import_effect16.Record.union(negatedCollectedAssets, import_effect16.BigInt.sum),
    import_effect16.Record.union(negatedMintedAssets, import_effect16.BigInt.sum)
  );
  const requiredAssets = (0, import_effect16.pipe)(
    assetsDelta,
    import_effect16.Record.filter((amount) => amount > 0n)
  );
  if (import_effect16.Record.isEmptyRecord(requiredAssets)) return [];
  const notRequiredAssets = (0, import_effect16.pipe)(
    assetsDelta,
    import_effect16.Record.filter((amount) => amount < 0n),
    negateAssets
  );
  const selected = recursive(
    (0, import_utils14.sortUTxOs)(availableInputs),
    requiredAssets,
    config.lucidConfig.protocolParameters.coinsPerUtxoByte,
    notRequiredAssets
  );
  if (import_effect16.Array.isEmptyArray(selected))
    yield* completeTxError(
      "NotFound",
      `Your wallet does not have enough funds to cover the required assets. ${(0, import_utils14.stringify)(requiredAssets)}`
    );
  return selected;
});
var evalTransaction = (config, txRedeemerBuilder, walletInputs) => import_effect16.Effect.gen(function* () {
  const txEvaluation = setRedeemerstoZero(txRedeemerBuilder.draft_tx());
  const txUtxos = [
    ...walletInputs,
    ...config.collectedInputs,
    ...config.readInputs
  ];
  const ins = txUtxos.map((utxo) => (0, import_utils14.utxoToTransactionInput)(utxo));
  const outs = txUtxos.map((utxo) => (0, import_utils14.utxoToTransactionOutput)(utxo));
  const slotConfig = import_plutus4.SLOT_CONFIG_NETWORK[config.lucidConfig.network];
  const uplc_eval = yield* import_effect16.Effect.try({
    try: () => UPLC.eval_phase_two_raw(
      txEvaluation.to_cbor_bytes(),
      ins.map((value) => value.to_cbor_bytes()),
      outs.map((value) => value.to_cbor_bytes()),
      config.lucidConfig.costModels.to_cbor_bytes(),
      config.lucidConfig.protocolParameters.maxTxExSteps,
      config.lucidConfig.protocolParameters.maxTxExMem,
      BigInt(slotConfig.zeroTime),
      BigInt(slotConfig.zeroSlot),
      slotConfig.slotLength
    ),
    catch: (error) => (
      //TODO: improve format
      completeTxError("UPLCEval", JSON.stringify(error).replace(/\\n/g, ""))
    )
  });
  return uplc_eval;
});
var calculateMinLovelace = (coinsPerUtxoByte, multiAssets, changeAddress) => {
  const dummyAddress = "addr_test1qrngfyc452vy4twdrepdjc50d4kvqutgt0hs9w6j2qhcdjfx0gpv7rsrjtxv97rplyz3ymyaqdwqa635zrcdena94ljs0xy950";
  return CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress ? changeAddress : dummyAddress)
  ).next().with_asset_and_min_required_coin(
    multiAssets ? (0, import_utils14.assetsToValue)(multiAssets).multi_asset() : CML.MultiAsset.new(),
    coinsPerUtxoByte
  ).build().output().amount().coin();
};
var deriveInputsFromTransaction = (tx) => {
  const outputs = tx.body().outputs();
  const txHash = CML.hash_transaction(tx.body()).to_hex();
  const utxos = [];
  for (let index = 0; index < outputs.len(); index++) {
    const output = outputs.get(index);
    const utxo = {
      txHash,
      outputIndex: index,
      ...(0, import_utils14.coreToTxOutput)(output)
    };
    utxos.push(utxo);
  }
  return utxos;
};
var negateAssets = (assets) => import_effect16.Record.map(assets, (amount) => -amount);
var sumAssetsFromInputs = (inputs) => import_effect16.Array.isEmptyArray(inputs) ? {} : inputs.map((utxo) => utxo.assets).reduce((acc, cur) => import_effect16.Record.union(acc, cur, import_effect16.BigInt.sum));
var calculateExtraLovelace = (leftoverAssets, coinsPerUtxoByte) => {
  return (0, import_effect16.pipe)(leftoverAssets, (assets) => {
    const minLovelace = calculateMinLovelace(coinsPerUtxoByte, assets);
    const currentLovelace = assets["lovelace"] || 0n;
    return currentLovelace > minLovelace ? import_effect16.Option.none() : import_effect16.Option.some({ lovelace: minLovelace - currentLovelace });
  });
};
var recursive = (inputs, requiredAssets, coinsPerUtxoByte, externalAssets = {}) => {
  let selected = (0, import_utils14.selectUTxOs)(inputs, requiredAssets);
  if (import_effect16.Array.isEmptyArray(selected)) return [];
  const selectedAssets = sumAssetsFromInputs(selected);
  let availableAssets = (0, import_effect16.pipe)(
    selectedAssets,
    import_effect16.Record.union(requiredAssets, (self, that) => self - that),
    import_effect16.Record.union(externalAssets, import_effect16.BigInt.sum)
  );
  let extraLovelace = (0, import_effect16.pipe)(
    calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
    import_effect16.Option.getOrUndefined
  );
  let remainingInputs = import_effect16.Array.differenceWith(import_utils14.isEqualUTxO)(
    inputs,
    selected
  );
  while (extraLovelace) {
    const extraSelected = (0, import_utils14.selectUTxOs)(remainingInputs, extraLovelace);
    if (import_effect16.Array.isEmptyArray(extraSelected)) {
      return [];
    }
    const extraSelectedAssets = sumAssetsFromInputs(extraSelected);
    selected = [...selected, ...extraSelected];
    availableAssets = import_effect16.Record.union(
      availableAssets,
      extraSelectedAssets,
      import_effect16.BigInt.sum
    );
    extraLovelace = (0, import_effect16.pipe)(
      calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
      import_effect16.Option.getOrUndefined
    );
    remainingInputs = import_effect16.Array.differenceWith(import_utils14.isEqualUTxO)(
      remainingInputs,
      selected
    );
  }
  return selected;
};

// src/tx-builder/TxBuilder.ts
var import_effect17 = require("effect");
function makeTxBuilder(lucidConfig) {
  const config = {
    lucidConfig,
    txBuilder: CML.TransactionBuilder.new(lucidConfig.txbuilderconfig),
    walletInputs: [],
    collectedInputs: [],
    readInputs: [],
    consumedInputs: [],
    totalOutputAssets: {},
    mintedAssets: {},
    scripts: /* @__PURE__ */ new Map(),
    programs: []
  };
  const txBuilder = {
    readFrom: (utxos) => {
      utxos.map((utxo) => {
        if (utxo.scriptRef) {
          const scriptKeyValue = attachScript(utxo.scriptRef);
          config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        }
      });
      const program = readFrom(config, utxos);
      config.programs.push(program);
      return txBuilder;
    },
    collectFrom: (utxos, redeemer) => {
      const program = collectFromUTxO(config, utxos, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    pay: {
      ToAddress: (address, assets) => {
        const program = payToAddress(config, address, assets);
        config.programs.push(program);
        return txBuilder;
      },
      ToAddressWithData: (address, outputDatum, assets, scriptRef) => {
        const program = payToAddressWithData(
          config,
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToContract: (address, outputDatum, assets, scriptRef) => {
        const program = payToContract(
          config,
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    addSigner: (address) => {
      const program = addSigner(config, address);
      config.programs.push(program);
      return txBuilder;
    },
    registerStake: (rewardAddress) => {
      const program = registerStake(config, rewardAddress);
      config.programs.push(program);
      return txBuilder;
    },
    deRegisterStake: (rewardAddress, redeemer) => {
      const program = deRegisterStake(config, rewardAddress, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    withdraw: (rewardAddress, amount, redeemer) => {
      const program = withdraw(config, rewardAddress, amount, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    mintAssets: (assets, redeemer) => {
      const program = mintAssets(config, assets, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    validFrom: (unixTime) => {
      const program = validFrom(config, unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    validTo: (unixTime) => {
      const program = validTo(config, unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    delegateTo: (rewardAddress, poolId, redeemer) => {
      const program = delegateTo(config, rewardAddress, poolId, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    attachMetadata: (label, metadata) => {
      const program = attachMetadata(config, label, metadata);
      config.programs.push(program);
      return txBuilder;
    },
    attach: {
      Script: (script) => {
        const scriptKeyValue = attachScript(script);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      SpendingValidator: (spendingValidator) => {
        const scriptKeyValue = attachSpendingValidator(spendingValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      MintingPolicy: (mintingPolicy) => {
        const scriptKeyValue = attachMintingPolicy(mintingPolicy);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      CertificateValidator: (certValidator) => {
        const scriptKeyValue = attachCertificateValidator(certValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      WithdrawalValidator: (withdrawalValidator) => {
        const scriptKeyValue = attachWithdrawalValidator(withdrawalValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      }
    },
    complete: (options) => makeReturn(
      complete(config, options).pipe(
        import_effect17.Effect.map((result) => result[2])
      )
    ).unsafeRun(),
    completeProgram: (options) => complete(config, options).pipe(
      import_effect17.Effect.map((result) => result[2])
    ),
    completeSafe: (options) => makeReturn(
      complete(config, options).pipe(
        import_effect17.Effect.map((result) => result[2])
      )
    ).safeRun(),
    chainProgram: (options) => complete(config, options),
    chain: (options) => makeReturn(complete(config, options)).unsafeRun(),
    chainSafe: (options) => makeReturn(complete(config, options)).safeRun(),
    config: () => config
  };
  return txBuilder;
}

// src/tx-builder/TxConfig.ts
var makeTxConfig = (protocolParameters, costModels) => {
  const exUnitsPrices = CML.ExUnitPrices.new(
    CML.Rational.new(
      BigInt(protocolParameters.priceMem * 1e8),
      100000000n
    ),
    CML.Rational.new(
      BigInt(protocolParameters.priceStep * 1e8),
      100000000n
    )
  );
  const txBuilderConfig = CML.TransactionBuilderConfigBuilder.new().fee_algo(
    CML.LinearFee.new(
      BigInt(protocolParameters.minFeeA),
      BigInt(protocolParameters.minFeeB)
    )
  ).coins_per_utxo_byte(protocolParameters.coinsPerUtxoByte).pool_deposit(protocolParameters.poolDeposit).key_deposit(protocolParameters.keyDeposit).max_value_size(protocolParameters.maxValSize).max_tx_size(protocolParameters.maxTxSize).ex_unit_prices(exUnitsPrices).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).cost_models(costModels).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).build();
  return txBuilderConfig;
};

// src/lucid-evolution/LucidEvolution.ts
var import_wallet = require("@lucid-evolution/wallet");
var Lucid = async (provider, network) => {
  const protocolParam = await provider.getProtocolParameters();
  const costModels = (0, import_utils16.createCostModels)(protocolParam.costModels);
  const config = {
    provider,
    network,
    wallet: void 0,
    costModels,
    txbuilderconfig: makeTxConfig(protocolParam, costModels),
    protocolParameters: protocolParam
  };
  return {
    config: () => config,
    wallet: () => config.wallet,
    overrideUTxOs: (utxos) => config.wallet?.overrideUTxOs(utxos),
    switchProvider: async (provider2) => {
      const protocolParam2 = await provider2.getProtocolParameters();
      const costModels2 = (0, import_utils16.createCostModels)(protocolParam2.costModels);
      config.provider = provider2;
      config.costModels = costModels2;
      config.txbuilderconfig = makeTxConfig(protocolParam2, costModels2);
      config.protocolParameters = protocolParam2;
    },
    newTx: () => makeTxBuilder(config),
    fromTx: (tx) => makeTxSignBuilder(
      config,
      CML.Transaction.from_cbor_hex(tx)
    ),
    selectWallet: {
      fromSeed: (seed) => {
        config.wallet = (0, import_wallet.makeWalletFromSeed)(config.provider, network, seed);
      },
      fromPrivateKey: (privateKey) => {
        config.wallet = (0, import_wallet.makeWalletFromPrivateKey)(
          config.provider,
          network,
          privateKey
        );
      },
      fromAPI: (walletAPI) => {
        config.wallet = (0, import_wallet.makeWalletFromAPI)(config.provider, walletAPI);
      },
      fromAddress: (address, utxos) => {
        config.wallet = (0, import_wallet.makeWalletFromAddress)(
          config.provider,
          network,
          address,
          utxos
        );
      }
    },
    currentSlot: () => {
      return (0, import_utils16.unixTimeToSlot)(config.network, Date.now());
    },
    utxosAt: (addressOrCredential) => config.provider.getUtxos(addressOrCredential),
    utxosAtWithUnit: (addressOrCredential, unit) => config.provider.getUtxosWithUnit(addressOrCredential, unit),
    utxoByUnit: (unit) => config.provider.getUtxoByUnit(unit),
    utxosByOutRef: (outRefs) => config.provider.getUtxosByOutRef(outRefs),
    delegationAt: config.provider.getDelegation,
    awaitTx: (txHash, checkInterval) => config.provider.awaitTx(txHash, checkInterval),
    datumOf: (utxo, type) => datumOf(config.provider, utxo, type),
    metadataOf: (unit) => metadataOf(config.provider, unit)
  };
};

// src/index.ts
__reExport(src_exports, require("@lucid-evolution/bip39"), module.exports);
__reExport(src_exports, require("@lucid-evolution/core-types"), module.exports);
__reExport(src_exports, require("@lucid-evolution/core-utils"), module.exports);
__reExport(src_exports, require("@lucid-evolution/plutus"), module.exports);
__reExport(src_exports, require("@lucid-evolution/provider"), module.exports);
__reExport(src_exports, require("@lucid-evolution/sign_data"), module.exports);
__reExport(src_exports, require("@lucid-evolution/utils"), module.exports);
__reExport(src_exports, require("@lucid-evolution/wallet"), module.exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ERROR_MESSAGE,
  Lucid,
  RunTimeError,
  TxBuilderError,
  TxSignerError,
  TxSubmitError,
  makeRunTimeError,
  makeTxBuilder,
  makeTxSignBuilder,
  signError,
  ...require("@lucid-evolution/bip39"),
  ...require("@lucid-evolution/core-types"),
  ...require("@lucid-evolution/core-utils"),
  ...require("@lucid-evolution/plutus"),
  ...require("@lucid-evolution/provider"),
  ...require("@lucid-evolution/sign_data"),
  ...require("@lucid-evolution/utils"),
  ...require("@lucid-evolution/wallet")
});
