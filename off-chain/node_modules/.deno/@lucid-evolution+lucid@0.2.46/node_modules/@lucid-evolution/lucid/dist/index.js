// src/core.ts
import { Effect } from "effect";
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var makeReturn = (program) => {
  return {
    unsafeRun: () => Effect.runPromise(program),
    safeRun: () => Effect.runPromise(Effect.either(program)),
    program: () => program
  };
};

// src/lucid-evolution/utils.ts
import { fromUnit, toUnit } from "@lucid-evolution/utils";
import { Data } from "@lucid-evolution/plutus";
var datumOf = async (provider, utxo, type) => {
  if (!utxo.datum) {
    if (!utxo.datumHash) {
      throw new Error("This UTxO does not have a datum hash.");
    }
    utxo.datum = await provider.getDatum(utxo.datumHash);
  }
  return Data.from(utxo.datum, type);
};
var metadataOf = async (provider, unit) => {
  const { policyId, name, label } = fromUnit(unit);
  switch (label) {
    case 222:
    case 333:
    case 444: {
      const utxo = await provider.getUtxoByUnit(toUnit(policyId, name, 100));
      const metadata = await datumOf(provider, utxo);
      return Data.toJson(metadata.fields[0]);
    }
    default:
      throw new Error("No variant matched.");
  }
};

// src/lucid-evolution/LucidEvolution.ts
import { createCostModels, unixTimeToSlot as unixTimeToSlot2 } from "@lucid-evolution/utils";

// src/tx-builder/internal/Collect.ts
import { Effect as Effect4 } from "effect";
import { Data as Data3 } from "@lucid-evolution/plutus";
import { utxoToCore } from "@lucid-evolution/utils";

// src/Errors.ts
import { Data as Data2 } from "effect";
var ERROR_MESSAGE = {
  MULTIPLE_POLICIES: "Only one policy id allowed. You can chain multiple mintAssets functions together if you need to mint assets with different policy ids. ",
  EMPTY_UTXO: "UTxO array is empty. If a Tx has been recently submitted, consider waiting for chain sync",
  MISSING_WALLET: "Please ensure that it has been properly configured and initialized",
  MISSING_REDEEMER: "redeemer can not be undefined"
};
var TxBuilderError = class extends Data2.TaggedError("TxBuilderError") {
};
var TxSignerError = class extends Data2.TaggedError("TxSignerError") {
};
var TxSubmitError = class extends Data2.TaggedError("TxSubmitError") {
};
var RunTimeError = class extends Data2.TaggedError("RunTimeError") {
};
var makeRunTimeError = (error) => {
  return new RunTimeError({
    message: JSON.stringify(String(error))
  });
};

// src/tx-builder/internal/Collect.ts
import * as CML2 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/tx-builder/internal/TxUtils.ts
import { Effect as Effect3 } from "effect";
import { networkToId } from "@lucid-evolution/utils";
import { getAddressDetails } from "@lucid-evolution/utils";
var toDatumOption = (outputDatum) => {
  switch (outputDatum.kind) {
    case "hash":
      return CML.DatumOption.new_hash(
        CML.DatumHash.from_hex(outputDatum.value)
      );
    case "asHash": {
      const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
      return CML.DatumOption.new_hash(CML.hash_plutus_data(plutusData));
    }
    case "inline": {
      const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
      return CML.DatumOption.new_datum(plutusData);
    }
  }
};
var toCMLAddress = (address, lucidConfig) => Effect3.gen(function* ($) {
  const { type } = yield* validateAddressDetails(address, lucidConfig);
  return type === "Byron" ? CML.ByronAddress.from_base58(address).to_address() : CML.Address.from_bech32(address);
});
var toV1 = (script) => CML.PlutusScript.from_v1(CML.PlutusV1Script.from_cbor_hex(script));
var toV2 = (script) => {
  const v2 = CML.PlutusV2Script.from_cbor_hex(script);
  return CML.PlutusScript.from_v2(v2);
};
var toPartial = (script, redeemer) => CML.PartialPlutusWitness.new(
  CML.PlutusScriptWitness.new_script(script),
  CML.PlutusData.from_cbor_hex(redeemer)
);
var validateAddressDetails = (address, lucidConfig) => Effect3.gen(function* ($) {
  const addressDetails = yield* $(
    Effect3.try({
      try: () => getAddressDetails(address),
      catch: (error) => new TxBuilderError({
        cause: "Address",
        message: String(error)
      })
    })
  );
  const actualNetworkId = networkToId(lucidConfig.network);
  if (addressDetails.networkId !== actualNetworkId)
    yield* new TxBuilderError({
      cause: "InvalidNetwork",
      message: `Invalid address: ${address}, Expected address with network id ${actualNetworkId}, current network ${lucidConfig.network}`
    });
  return addressDetails;
});

// src/tx-builder/internal/Collect.ts
import { paymentCredentialOf } from "@lucid-evolution/utils";
var collectError = (cause, message) => new TxBuilderError({ cause, module: "Collect", message });
var collectFromUTxO = (config, utxos, redeemer) => Effect4.gen(function* ($) {
  if (utxos.length === 0)
    yield* $(collectError("EmptyUTXO", ERROR_MESSAGE.EMPTY_UTXO));
  for (const utxo of utxos) {
    if (utxo.datumHash && !utxo.datum) {
      const data = yield* $(
        Effect4.tryPromise({
          try: () => datumOf(config.lucidConfig.provider, utxo),
          catch: (error) => collectError("Datum", String(error))
        })
      );
      utxo.datum = Data3.to(data);
    }
    const coreUtxo = utxoToCore(utxo);
    config.collectedInputs.push(utxo);
    const input = CML2.SingleInputBuilder.from_transaction_unspent_output(coreUtxo);
    const credential = paymentCredentialOf(utxo.address);
    if (credential.type == "Script") {
      const script = yield* $(
        Effect4.fromNullable(config.scripts.get(credential.hash)),
        Effect4.orElseFail(
          () => collectError(
            "MissingScript",
            `No script found, script hash: ${credential.hash}, consider using attach modules`
          )
        )
      );
      switch (script.type) {
        case "Native":
          config.txBuilder.add_input(
            input.native_script(
              CML2.NativeScript.from_cbor_hex(script.script),
              CML2.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        case "PlutusV1": {
          const red = yield* $(
            Effect4.fromNullable(redeemer),
            Effect4.orElseFail(
              () => collectError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          config.txBuilder.add_input(
            input.plutus_script(
              toPartial(toV1(script.script), red),
              CML2.Ed25519KeyHashList.new(),
              CML2.PlutusData.from_cbor_hex(utxo.datum)
            )
          );
          break;
        }
        case "PlutusV2": {
          const v2 = toV2(script.script);
          const red = yield* $(
            Effect4.fromNullable(redeemer),
            Effect4.orElseFail(
              () => collectError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          const partial = toPartial(v2, red);
          config.txBuilder.add_input(
            //TODO: Test with DatumHash
            input.plutus_script_inline_datum(
              partial,
              CML2.Ed25519KeyHashList.new()
            )
          );
          break;
        }
      }
    } else {
      config.txBuilder.add_input(input.payment_key());
    }
  }
});

// src/tx-builder/internal/Read.ts
import { Effect as Effect5 } from "effect";
import { Data as Data4 } from "@lucid-evolution/plutus";
import { utxoToCore as utxoToCore2 } from "@lucid-evolution/utils";
var readError = (cause, message) => new TxBuilderError({ cause, module: "Read", message });
var readFrom = (config, utxos) => Effect5.gen(function* () {
  if (utxos.length === 0)
    yield* readError("EmptyUTXO", ERROR_MESSAGE.EMPTY_UTXO);
  for (const utxo of utxos) {
    if (utxo.datumHash) {
      const data = yield* Effect5.tryPromise({
        try: () => datumOf(config.lucidConfig.provider, utxo),
        catch: (error) => readError("Datum", String(error))
      });
      utxo.datum = Data4.to(data);
    }
    const coreUtxo = utxoToCore2(utxo);
    config.readInputs.push(utxo);
    config.txBuilder.add_reference_input(coreUtxo);
  }
});

// src/tx-builder/internal/Attach.ts
import { applyDoubleCborEncoding } from "@lucid-evolution/utils";
var attachScript = ({
  type,
  script
}) => {
  switch (type) {
    case "Native":
      return {
        key: CML.NativeScript.from_cbor_hex(script).hash().to_hex(),
        value: { type, script }
      };
    case "PlutusV1":
      return {
        key: CML.PlutusV1Script.from_cbor_hex(applyDoubleCborEncoding(script)).hash().to_hex(),
        value: { type, script: applyDoubleCborEncoding(script) }
      };
    case "PlutusV2":
      return {
        key: CML.PlutusV2Script.from_cbor_hex(applyDoubleCborEncoding(script)).hash().to_hex(),
        value: { type, script: applyDoubleCborEncoding(script) }
      };
  }
};
var attachSpendingValidator = (spendingValidator) => attachScript(spendingValidator);
var attachMintingPolicy = (mintingPolicy) => attachScript(mintingPolicy);
var attachCertificateValidator = (certValidator) => attachScript(certValidator);
var attachWithdrawalValidator = (withdrawalValidator) => attachScript(withdrawalValidator);

// src/tx-builder/internal/Pay.ts
import { Effect as Effect6 } from "effect";
import {
  addAssets,
  assetsToValue,
  toScriptRef,
  valueToAssets
} from "@lucid-evolution/utils";
var payError = (cause, message) => new TxBuilderError({ cause, module: "Pay", message });
var payToAddress = (config, address, assets) => Effect6.gen(function* () {
  const outputBuilder = CML.TransactionOutputBuilder.new().with_address(yield* toCMLAddress(address, config.lucidConfig)).next();
  if (Object.keys(assets).length == 0)
    yield* payError(
      "EmptyAssets",
      "Attempting to pay to an address with an empty assets object"
    );
  if (assets["lovelace"]) {
    const outputResult = outputBuilder.with_value(assetsToValue(assets)).build();
    config.totalOutputAssets = addAssets(
      config.totalOutputAssets,
      valueToAssets(outputResult.output().amount())
    );
    config.txBuilder.add_output(outputResult);
  } else {
    const outputResult = outputBuilder.with_asset_and_min_required_coin(
      assetsToValue(assets).multi_asset(),
      config.lucidConfig.protocolParameters.coinsPerUtxoByte
    ).build();
    config.totalOutputAssets = addAssets(
      config.totalOutputAssets,
      valueToAssets(outputResult.output().amount())
    );
    config.txBuilder.add_output(outputResult);
  }
});
var payToAddressWithData = (config, address, outputDatum, assets, scriptRef) => Effect6.gen(function* () {
  const outputBuilder = buildBaseOutput(address, outputDatum, scriptRef);
  if (assets) {
    if (Object.keys(assets).length == 0)
      yield* payError(
        "EmptyAssets",
        "Attempting to pay to an address with an empty assets object"
      );
    if (assets["lovelace"]) {
      const outputResult = outputBuilder.with_value(assetsToValue(assets)).build();
      config.totalOutputAssets = addAssets(
        config.totalOutputAssets,
        valueToAssets(outputResult.output().amount())
      );
      config.txBuilder.add_output(outputResult);
    } else {
      const outputResult = outputBuilder.with_asset_and_min_required_coin(
        assetsToValue(assets).multi_asset(),
        config.lucidConfig.protocolParameters.coinsPerUtxoByte
      ).build();
      config.totalOutputAssets = addAssets(
        config.totalOutputAssets,
        valueToAssets(outputResult.output().amount())
      );
      config.txBuilder.add_output(outputResult);
    }
  } else {
    const outputResult = outputBuilder.with_asset_and_min_required_coin(
      CML.MultiAsset.new(),
      config.lucidConfig.protocolParameters.coinsPerUtxoByte
    ).build();
    config.totalOutputAssets = addAssets(
      config.totalOutputAssets,
      valueToAssets(outputResult.output().amount())
    );
    config.txBuilder.add_output(outputResult);
  }
});
var payToContract = (config, address, outputDatum, assets, scriptRef) => Effect6.gen(function* () {
  if (!outputDatum.value)
    yield* payError(
      "Datum",
      "No datum set. Script output becomes unspendable without datum."
    );
  return yield* payToAddressWithData(
    config,
    address,
    outputDatum,
    assets,
    scriptRef
  );
});
var buildBaseOutput = (address, outputDatum, scriptRef) => {
  const baseBuilder = CML.TransactionOutputBuilder.new().with_address(CML.Address.from_bech32(address)).with_data(toDatumOption(outputDatum));
  return scriptRef ? baseBuilder.with_reference_script(toScriptRef(scriptRef)).next() : baseBuilder.next();
};

// src/tx-builder/internal/Mint.ts
import { Effect as Effect7, pipe as pipe2 } from "effect";
import { fromHex } from "@lucid-evolution/core-utils";
import * as CML3 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
import { addAssets as addAssets2 } from "@lucid-evolution/utils";
var mintError = (cause, message) => new TxBuilderError({ cause, module: "Mint", message });
var mintAssets = (config, assets, redeemer) => Effect7.gen(function* () {
  config.mintedAssets = addAssets2(config.mintedAssets, assets);
  const units = Object.keys(assets);
  const policyId = units[0].slice(0, 56);
  const mintAssets2 = CML3.MapAssetNameToNonZeroInt64.new();
  for (const unit of units) {
    if (unit.slice(0, 56) !== policyId) {
      yield* mintError("MultiplePolicies", ERROR_MESSAGE.MULTIPLE_POLICIES);
    }
    mintAssets2.insert(
      CML3.AssetName.from_bytes(fromHex(unit.slice(56))),
      assets[unit]
    );
  }
  const mintBuilder = CML3.SingleMintBuilder.new(mintAssets2);
  const policy = yield* pipe2(
    Effect7.fromNullable(config.scripts.get(policyId)),
    Effect7.orElseFail(
      () => mintError("MissingPolicy", `No policy found, policy id: ${policyId}`)
    )
  );
  switch (policy.type) {
    case "Native":
      config.txBuilder.add_mint(
        mintBuilder.native_script(
          CML3.NativeScript.from_cbor_hex(policy.script),
          CML3.NativeScriptWitnessInfo.assume_signature_count()
        )
      );
      break;
    case "PlutusV1": {
      const red = yield* pipe2(
        Effect7.fromNullable(redeemer),
        Effect7.orElseFail(
          () => mintError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV1(policy.script), red),
          CML3.Ed25519KeyHashList.new()
        )
      );
      break;
    }
    case "PlutusV2": {
      const red = yield* pipe2(
        Effect7.fromNullable(redeemer),
        Effect7.orElseFail(
          () => mintError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV2(policy.script), red),
          CML3.Ed25519KeyHashList.new()
        )
      );
      break;
    }
  }
});

// src/tx-builder/internal/Interval.ts
import { Effect as Effect8 } from "effect";
import { unixTimeToSlot } from "@lucid-evolution/utils";
var validFrom = (config, unixTime) => Effect8.gen(function* () {
  const slot = unixTimeToSlot(config.lucidConfig.network, unixTime);
  config.txBuilder.set_validity_start_interval(BigInt(slot));
});
var validTo = (config, unixTime) => Effect8.gen(function* () {
  const slot = unixTimeToSlot(config.lucidConfig.network, unixTime);
  config.txBuilder.set_ttl(BigInt(slot));
});

// src/tx-builder/internal/Signer.ts
import { Effect as Effect9 } from "effect";
import * as CML4 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var addSignerError = (cause, message) => new TxBuilderError({ cause, module: "Signer", message });
var addSigner = (config, address) => Effect9.gen(function* () {
  const addressDetails = yield* validateAddressDetails(
    address,
    config.lucidConfig
  );
  if (!addressDetails.paymentCredential && !addressDetails.stakeCredential)
    yield* addSignerError(
      "NotFound",
      "undefined paymentCredential and stakeCredential"
    );
  const credential = addressDetails.type === "Reward" ? addressDetails.stakeCredential : addressDetails.paymentCredential;
  if (credential.type === "Script")
    yield* addSignerError(
      "InvalidCredential",
      "Only key hashes are allowed as signers."
    );
  return credential.hash;
}).pipe(Effect9.flatMap((keyHash) => addSignerKey(config, keyHash)));
var addSignerKey = (config, keyHash) => Effect9.gen(function* () {
  config.txBuilder.add_required_signer(CML4.Ed25519KeyHash.from_hex(keyHash));
});

// src/tx-builder/internal/Stake.ts
import { Effect as Effect10, pipe as pipe3 } from "effect";
import * as CML5 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var stakeError = (cause, message) => new TxBuilderError({ cause, module: "Stake", message });
var registerStake = (config, rewardAddress) => Effect10.gen(function* () {
  const addressDetails = yield* pipe3(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect10.andThen(
      (address) => address.type !== "Reward" ? stakeError("InvalidCredential", "Address type must be Reward type.") : Effect10.succeed(address)
    )
  );
  const stakeCredential = yield* pipe3(
    Effect10.fromNullable(addressDetails.stakeCredential),
    Effect10.orElseFail(() => stakeError("MissingStakeCredential"))
  );
  const credential = stakeCredential.type === "Key" ? CML5.Credential.new_pub_key(
    CML5.Ed25519KeyHash.from_hex(stakeCredential.hash)
  ) : CML5.Credential.new_script(
    CML5.ScriptHash.from_hex(stakeCredential.hash)
  );
  const certBuilder = CML5.SingleCertificateBuilder.new(
    CML5.Certificate.new_stake_registration(credential)
  );
  config.txBuilder.add_cert(certBuilder.skip_witness());
});
var deRegisterStake = (config, rewardAddress, redeemer) => Effect10.gen(function* () {
  const addressDetails = yield* pipe3(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect10.andThen(
      (address) => address.type !== "Reward" ? stakeError("InvalidCredential", "Address type must be Reward type.") : Effect10.succeed(address)
    )
  );
  const stakeCredential = yield* pipe3(
    Effect10.fromNullable(addressDetails.stakeCredential),
    Effect10.orElseFail(() => stakeError("MissingStakeCredential"))
  );
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML5.Credential.new_pub_key(
        CML5.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML5.SingleCertificateBuilder.new(
        CML5.Certificate.new_stake_deregistration(credential)
      );
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML5.Credential.new_script(
        CML5.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML5.SingleCertificateBuilder.new(
        CML5.Certificate.new_stake_deregistration(credential)
      );
      const script = yield* pipe3(
        Effect10.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect10.orElseFail(
          () => stakeError(
            "MissingScript",
            `No script found, script hash: ${stakeCredential.hash}, consider using attach modules`
          )
        )
      );
      const red = yield* pipe3(
        Effect10.fromNullable(redeemer),
        Effect10.orElseFail(
          () => stakeError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          yield* stakeError("NotFound");
          break;
        }
      }
    }
  }
});
var withdraw = (config, rewardAddress, amount, redeemer) => Effect10.gen(function* ($) {
  const addressDetails = yield* pipe3(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect10.andThen(
      (address) => address.type !== "Reward" ? stakeError("InvalidCredential", "Address type must be Reward type.") : Effect10.succeed(address)
    )
  );
  const withdrawBuilder = yield* pipe3(
    Effect10.fromNullable(
      CML5.RewardAddress.from_address(CML5.Address.from_bech32(rewardAddress))
    ),
    Effect10.orElseFail(() => stakeError("MissingStakeCredential")),
    Effect10.andThen(
      (address) => CML5.SingleWithdrawalBuilder.new(address, amount)
    )
  );
  const stakeCredential = yield* pipe3(
    Effect10.fromNullable(addressDetails.stakeCredential),
    Effect10.orElseFail(() => stakeError("MissingStakeCredential"))
  );
  switch (stakeCredential.type) {
    case "Key": {
      config.txBuilder.add_withdrawal(withdrawBuilder.payment_key());
      break;
    }
    case "Script": {
      const script = yield* pipe3(
        Effect10.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect10.orElseFail(
          () => stakeError(
            "MissingScript",
            `No script found, script hash: ${stakeCredential.hash}, consider using attach modules`
          )
        )
      );
      const red = yield* pipe3(
        Effect10.fromNullable(redeemer),
        Effect10.orElseFail(
          () => stakeError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML5.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          yield* stakeError("NotFound");
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Pool.ts
import { Effect as Effect11, pipe as pipe4 } from "effect";
import * as CML6 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
import { fromText } from "@lucid-evolution/core-utils";
var poolError = (cause, message) => new TxBuilderError({ cause, module: "Pool", message });
var delegateTo = (config, rewardAddress, poolId, redeemer) => Effect11.gen(function* () {
  const addressDetails = yield* pipe4(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect11.andThen(
      (address) => address.type !== "Reward" ? poolError("InvalidCredential", "Address type must be Reward type.") : Effect11.succeed(address)
    )
  );
  const stakeCredential = yield* pipe4(
    Effect11.fromNullable(addressDetails.stakeCredential),
    Effect11.orElseFail(() => poolError("MissingStakeCredential"))
  );
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML6.Credential.new_pub_key(
        CML6.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML6.SingleCertificateBuilder.new(
        CML6.Certificate.new_stake_delegation(
          credential,
          CML6.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML6.Credential.new_script(
        CML6.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML6.SingleCertificateBuilder.new(
        CML6.Certificate.new_stake_delegation(
          credential,
          CML6.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      const script = yield* pipe4(
        Effect11.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect11.orElseFail(
          () => poolError(
            "MissingScript",
            `No script found, script hash: ${stakeCredential.hash}, consider using attach modules`
          )
        )
      );
      const red = yield* pipe4(
        Effect11.fromNullable(redeemer),
        Effect11.orElseFail(
          () => poolError("MissingRedeemer", ERROR_MESSAGE.MISSING_REDEEMER)
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          yield* poolError("NotFound");
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Metadata.ts
import { Effect as Effect12 } from "effect";
import * as S from "@effect/schema/Schema";
import { toHex } from "@lucid-evolution/core-utils";
var attachMetadata = (config, label, metadata) => Effect12.gen(function* () {
  const auxiliaryData = CML.AuxiliaryData.new();
  const meta = CML.Metadata.new();
  meta.set(
    BigInt(label),
    CML.TransactionMetadatum.from_json(
      JSON.stringify(toCardanoMetadata(metadata))
    )
  );
  auxiliaryData.add_metadata(meta);
  config.txBuilder.add_auxiliary_data(auxiliaryData);
  auxiliaryData.free();
  meta.free();
});
var TextSchema = S.String.pipe(S.maxLength(64));
var TransactionMetadataSchema = S.Union(
  TextSchema,
  S.Number,
  S.Uint8ArrayFromSelf,
  S.Array(S.suspend(() => TransactionMetadataSchema)),
  S.Record(
    S.String,
    S.suspend(() => TransactionMetadataSchema)
  )
);
var toCardanoMetadata = (json) => {
  const d = S.asserts(TransactionMetadataSchema)(json);
  if (S.is(TextSchema)(json)) {
    return { string: json };
  }
  if (typeof json === "number") {
    return { int: json };
  }
  if (json instanceof Uint8Array) {
    return { bytes: toHex(json) };
  }
  if (Array.isArray(json)) {
    return { list: json.map((value) => toCardanoMetadata(value)) };
  }
  if (typeof json === "object" && json !== null) {
    const mapEntries = Object.entries(json).map(([k, v]) => ({
      k: toCardanoMetadata(k),
      v: toCardanoMetadata(v)
    }));
    return { map: mapEntries };
  }
  throw new Error("Unsupported type");
};

// src/tx-builder/internal/CompleteTxBuilder.ts
import {
  Effect as Effect16,
  pipe as pipe7,
  Record as Record2,
  Array as _Array,
  BigInt as _BigInt,
  Tuple,
  Option
} from "effect";
import * as UPLC from "@lucid-evolution/uplc";

// src/tx-sign-builder/internal/CompleteTxSigner.ts
import { Effect as Effect14, pipe as pipe5 } from "effect";

// src/tx-submit/TxSubmit.ts
import { Effect as Effect13 } from "effect";
var submitError = (cause, message) => new TxSubmitError({ cause, module: "Submit", message });
var makeSubmit = (wallet, txSigned) => {
  const submit = Effect13.tryPromise({
    try: () => wallet.submitTx(txSigned.to_cbor_hex()),
    catch: (error) => submitError("SubmitError", String(error))
  });
  return {
    submit: () => makeReturn(submit).unsafeRun(),
    submitProgram: () => makeReturn(submit).program(),
    submitSafe: () => makeReturn(submit).safeRun(),
    toCBOR: () => txSigned.to_cbor_hex(),
    toHash: () => CML.hash_transaction(txSigned.body()).to_hex()
  };
};

// src/tx-sign-builder/internal/CompleteTxSigner.ts
import { stringify } from "@lucid-evolution/utils";
var completeTxSigner = (config) => Effect14.gen(function* () {
  yield* Effect14.all(config.programs, { concurrency: "unbounded" });
  config.witnessSetBuilder.add_existing(config.txComplete.witness_set());
  const txWitnessSet = config.witnessSetBuilder.build();
  const signedTx = CML.Transaction.new(
    config.txComplete.body(),
    txWitnessSet,
    true,
    config.txComplete.auxiliary_data()
  );
  const wallet = yield* pipe5(
    Effect14.fromNullable(config.lucidConfig.wallet),
    Effect14.orElseFail(
      () => signError("MissingWallet", ERROR_MESSAGE.MISSING_WALLET)
    )
  );
  return makeSubmit(wallet, signedTx);
}).pipe(
  Effect14.catchAllDefect(
    (e) => new RunTimeError({ message: stringify(String(e)) })
  )
);

// src/tx-sign-builder/internal/Sign.ts
import { Effect as Effect15, pipe as pipe6 } from "effect";
var signError2 = (cause, message) => new TxSignerError({ cause, module: "Sign", message });
var withWallet = (config) => Effect15.gen(function* () {
  const wallet = yield* pipe6(
    Effect15.fromNullable(config.lucidConfig.wallet),
    Effect15.orElseFail(
      () => signError2("MissingWallet", ERROR_MESSAGE.MISSING_WALLET)
    )
  );
  const witnesses = yield* Effect15.tryPromise({
    try: () => wallet.signTx(config.txComplete),
    catch: (error) => signError2("Signature", String(error))
  });
  config.witnessSetBuilder.add_existing(witnesses);
});
var withPrivateKey = (config, privateKey) => Effect15.gen(function* () {
  const priv = CML.PrivateKey.from_bech32(privateKey);
  const witness = CML.make_vkey_witness(
    CML.hash_transaction(config.txComplete.body()),
    priv
  );
  config.witnessSetBuilder.add_vkey(witness);
});

// src/tx-sign-builder/TxSignBuilder.ts
var signError = (cause, message) => new TxSignerError({ cause, module: "Sign", message });
var makeTxSignBuilder = (lucidConfig, tx) => {
  const redeemers = tx.witness_set().redeemers();
  const exUnits = { cpu: 0, mem: 0 };
  if (redeemers) {
    for (let i = 0; i < redeemers.as_arr_legacy_redeemer().len(); i++) {
      const redeemer = redeemers.as_arr_legacy_redeemer().get(i);
      exUnits.cpu += parseInt(redeemer.ex_units().steps().toString());
      exUnits.mem += parseInt(redeemer.ex_units().mem().toString());
    }
  }
  const config = {
    txComplete: tx,
    witnessSetBuilder: CML.TransactionWitnessSetBuilder.new(),
    programs: [],
    lucidConfig,
    fee: parseInt(tx.body().fee().toString()),
    exUnits
  };
  const txSignBuilder = {
    sign: {
      withWallet: () => {
        const program = withWallet(config);
        config.programs.push(program);
        return txSignBuilder;
      },
      withPrivateKey: (privateKey) => {
        const program = withPrivateKey(config, privateKey);
        config.programs.push(program);
        return txSignBuilder;
      }
    },
    complete: () => makeReturn(completeTxSigner(config)).unsafeRun(),
    completeProgram: () => makeReturn(completeTxSigner(config)).program(),
    completeSafe: () => makeReturn(completeTxSigner(config)).safeRun()
  };
  return txSignBuilder;
};

// src/tx-builder/internal/CompleteTxBuilder.ts
import {
  assetsToValue as assetsToValue2,
  coreToTxOutput,
  isEqualUTxO,
  selectUTxOs,
  sortUTxOs,
  stringify as stringify2,
  utxoToCore as utxoToCore3,
  utxoToTransactionInput,
  utxoToTransactionOutput
} from "@lucid-evolution/utils";
import { SLOT_CONFIG_NETWORK } from "@lucid-evolution/plutus";
var completeTxError = (cause, message) => new TxBuilderError({ cause, module: "Complete", message });
var getWalletInfo = (config) => Effect16.gen(function* () {
  const wallet = yield* pipe7(
    Effect16.fromNullable(config.lucidConfig.wallet),
    Effect16.orElseFail(
      () => completeTxError("MissingWallet", ERROR_MESSAGE.MISSING_WALLET)
    )
  );
  const address = yield* Effect16.promise(() => wallet.address());
  const inputs = yield* pipe7(
    Effect16.tryPromise({
      try: () => wallet.getUtxos(),
      catch: (error) => completeTxError("Provider", String(error))
    })
  );
  const walletInputs = _Array.isEmptyArray(config.walletInputs) ? inputs : config.walletInputs;
  return {
    wallet,
    address,
    inputs: walletInputs
  };
});
var complete = (config, options = { coinSelection: true, localUPLCEval: true }) => Effect16.gen(function* () {
  yield* Effect16.all(config.programs, { concurrency: "unbounded" });
  const walletInfo = yield* getWalletInfo(config);
  if (config.scripts.size > 0) {
    const collateralInput = yield* findCollateral(
      config.lucidConfig.protocolParameters.coinsPerUtxoByte,
      walletInfo.inputs
    );
    setCollateral(config, collateralInput, walletInfo.address);
  }
  const availableInputs = _Array.differenceWith(isEqualUTxO)(
    walletInfo.inputs,
    config.collectedInputs
  );
  const inputsToAdd = options.coinSelection !== false ? yield* coinSelection(config, availableInputs) : [];
  for (const utxo of inputsToAdd) {
    const input = CML.SingleInputBuilder.from_transaction_unspent_output(
      utxoToCore3(utxo)
    ).payment_key();
    config.txBuilder.add_input(input);
  }
  config.consumedInputs = [...config.collectedInputs, ...inputsToAdd];
  const txRedeemerBuilder = yield* Effect16.try({
    try: () => config.txBuilder.build_for_evaluation(
      0,
      CML.Address.from_bech32(walletInfo.address)
    ),
    catch: (error) => completeTxError("BuildEvaluation", String(error))
  });
  if (options.localUPLCEval !== false && txRedeemerBuilder.draft_tx().witness_set().redeemers()) {
    applyUPLCEval(
      yield* evalTransaction(config, txRedeemerBuilder, walletInfo.inputs),
      config.txBuilder
    );
  }
  config.txBuilder.add_change_if_needed(
    CML.Address.from_bech32(walletInfo.address),
    true
  );
  const tx = yield* Effect16.try({
    try: () => config.txBuilder.build(
      CML.ChangeSelectionAlgo.Default,
      CML.Address.from_bech32(walletInfo.address)
    ).build_unchecked(),
    catch: (error) => completeTxError("Build", String(error))
  });
  const derivedInputs = deriveInputsFromTransaction(tx);
  const derivedWalletInputs = derivedInputs.filter(
    (utxo) => utxo.address === walletInfo.address
  );
  const updatedWalletInputs = pipe7(
    _Array.differenceWith(isEqualUTxO)(
      walletInfo.inputs,
      config.consumedInputs
    ),
    (availableWalletInputs) => [
      ...derivedWalletInputs,
      ...availableWalletInputs
    ]
  );
  return Tuple.make(
    updatedWalletInputs,
    derivedInputs,
    makeTxSignBuilder(config.lucidConfig, tx)
  );
}).pipe(
  Effect16.catchAllDefect(
    (e) => new RunTimeError({ message: stringify2(String(e)) })
  )
);
var applyUPLCEval = (uplcEval, txbuilder) => {
  for (const bytes of uplcEval) {
    const redeemer = CML.LegacyRedeemer.from_cbor_bytes(bytes);
    const exUnits = CML.ExUnits.new(
      redeemer.ex_units().mem(),
      redeemer.ex_units().steps()
    );
    txbuilder.set_exunits(
      CML.RedeemerWitnessKey.new(redeemer.tag(), redeemer.index()),
      exUnits
    );
  }
};
var setRedeemerstoZero = (tx) => {
  const redeemers = tx.witness_set().redeemers();
  if (redeemers) {
    const redeemerList = CML.LegacyRedeemerList.new();
    for (let i = 0; i < redeemers.as_arr_legacy_redeemer().len(); i++) {
      const redeemer = redeemers.as_arr_legacy_redeemer().get(i);
      const dummyRedeemer = CML.LegacyRedeemer.new(
        redeemer.tag(),
        redeemer.index(),
        redeemer.data(),
        CML.ExUnits.new(0n, 0n)
      );
      redeemerList.add(dummyRedeemer);
    }
    const dummyWitnessSet = tx.witness_set();
    dummyWitnessSet.set_redeemers(
      CML.Redeemers.new_arr_legacy_redeemer(redeemerList)
    );
    return CML.Transaction.new(
      tx.body(),
      dummyWitnessSet,
      true,
      tx.auxiliary_data()
    );
  }
};
var setCollateral = (config, collateralInputs, changeAddress) => {
  for (const utxo of collateralInputs) {
    const collateralInput = CML.SingleInputBuilder.from_transaction_unspent_output(
      utxoToCore3(utxo)
    ).payment_key();
    config.txBuilder.add_collateral(collateralInput);
  }
  const returnassets = pipe7(
    sumAssetsFromInputs(collateralInputs),
    Record2.union({ lovelace: -5000000n }, _BigInt.sum)
  );
  const collateralOutputBuilder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress)
  );
  config.txBuilder.set_collateral_return(
    collateralOutputBuilder.next().with_value(assetsToValue2(returnassets)).build().output()
  );
};
var findCollateral = (coinsPerUtxoByte, inputs) => Effect16.gen(function* () {
  const minLovelaceChangeAddress = {
    lovelace: calculateMinLovelace(coinsPerUtxoByte)
  };
  const collateralLovelace = { lovelace: 5000000n };
  const requiredAssets = Record2.union(
    minLovelaceChangeAddress,
    collateralLovelace,
    _BigInt.sum
  );
  const selected = recursive(
    sortUTxOs(inputs),
    collateralLovelace,
    coinsPerUtxoByte
  );
  if (_Array.isEmptyArray(selected))
    yield* completeTxError(
      "MissingCollateral",
      `Your wallet does not have enough funds to cover the required 5 ADA collateral.`
    );
  if (selected.length > 3)
    yield* completeTxError(
      "MissingCollateral",
      `Selected ${selected.length} inputs as collateral, but max collateral inputs is 3 to cover the 5 ADA collateral ${stringify2(selected)}`
    );
  return selected;
});
var coinSelection = (config, availableInputs) => Effect16.gen(function* () {
  const estimatedFee = { lovelace: 2000000n };
  const negatedMintedAssets = negateAssets(config.mintedAssets);
  const negatedCollectedAssets = negateAssets(
    sumAssetsFromInputs(config.collectedInputs)
  );
  const assetsDelta = pipe7(
    config.totalOutputAssets,
    Record2.union(estimatedFee, _BigInt.sum),
    Record2.union(negatedCollectedAssets, _BigInt.sum),
    Record2.union(negatedMintedAssets, _BigInt.sum)
  );
  const requiredAssets = pipe7(
    assetsDelta,
    Record2.filter((amount) => amount > 0n)
  );
  if (Record2.isEmptyRecord(requiredAssets)) return [];
  const notRequiredAssets = pipe7(
    assetsDelta,
    Record2.filter((amount) => amount < 0n),
    negateAssets
  );
  const selected = recursive(
    sortUTxOs(availableInputs),
    requiredAssets,
    config.lucidConfig.protocolParameters.coinsPerUtxoByte,
    notRequiredAssets
  );
  if (_Array.isEmptyArray(selected))
    yield* completeTxError(
      "NotFound",
      `Your wallet does not have enough funds to cover the required assets. ${stringify2(requiredAssets)}`
    );
  return selected;
});
var evalTransaction = (config, txRedeemerBuilder, walletInputs) => Effect16.gen(function* () {
  const txEvaluation = setRedeemerstoZero(txRedeemerBuilder.draft_tx());
  const txUtxos = [
    ...walletInputs,
    ...config.collectedInputs,
    ...config.readInputs
  ];
  const ins = txUtxos.map((utxo) => utxoToTransactionInput(utxo));
  const outs = txUtxos.map((utxo) => utxoToTransactionOutput(utxo));
  const slotConfig = SLOT_CONFIG_NETWORK[config.lucidConfig.network];
  const uplc_eval = yield* Effect16.try({
    try: () => UPLC.eval_phase_two_raw(
      txEvaluation.to_cbor_bytes(),
      ins.map((value) => value.to_cbor_bytes()),
      outs.map((value) => value.to_cbor_bytes()),
      config.lucidConfig.costModels.to_cbor_bytes(),
      config.lucidConfig.protocolParameters.maxTxExSteps,
      config.lucidConfig.protocolParameters.maxTxExMem,
      BigInt(slotConfig.zeroTime),
      BigInt(slotConfig.zeroSlot),
      slotConfig.slotLength
    ),
    catch: (error) => (
      //TODO: improve format
      completeTxError("UPLCEval", JSON.stringify(error).replace(/\\n/g, ""))
    )
  });
  return uplc_eval;
});
var calculateMinLovelace = (coinsPerUtxoByte, multiAssets, changeAddress) => {
  const dummyAddress = "addr_test1qrngfyc452vy4twdrepdjc50d4kvqutgt0hs9w6j2qhcdjfx0gpv7rsrjtxv97rplyz3ymyaqdwqa635zrcdena94ljs0xy950";
  return CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress ? changeAddress : dummyAddress)
  ).next().with_asset_and_min_required_coin(
    multiAssets ? assetsToValue2(multiAssets).multi_asset() : CML.MultiAsset.new(),
    coinsPerUtxoByte
  ).build().output().amount().coin();
};
var deriveInputsFromTransaction = (tx) => {
  const outputs = tx.body().outputs();
  const txHash = CML.hash_transaction(tx.body()).to_hex();
  const utxos = [];
  for (let index = 0; index < outputs.len(); index++) {
    const output = outputs.get(index);
    const utxo = {
      txHash,
      outputIndex: index,
      ...coreToTxOutput(output)
    };
    utxos.push(utxo);
  }
  return utxos;
};
var negateAssets = (assets) => Record2.map(assets, (amount) => -amount);
var sumAssetsFromInputs = (inputs) => _Array.isEmptyArray(inputs) ? {} : inputs.map((utxo) => utxo.assets).reduce((acc, cur) => Record2.union(acc, cur, _BigInt.sum));
var calculateExtraLovelace = (leftoverAssets, coinsPerUtxoByte) => {
  return pipe7(leftoverAssets, (assets) => {
    const minLovelace = calculateMinLovelace(coinsPerUtxoByte, assets);
    const currentLovelace = assets["lovelace"] || 0n;
    return currentLovelace > minLovelace ? Option.none() : Option.some({ lovelace: minLovelace - currentLovelace });
  });
};
var recursive = (inputs, requiredAssets, coinsPerUtxoByte, externalAssets = {}) => {
  let selected = selectUTxOs(inputs, requiredAssets);
  if (_Array.isEmptyArray(selected)) return [];
  const selectedAssets = sumAssetsFromInputs(selected);
  let availableAssets = pipe7(
    selectedAssets,
    Record2.union(requiredAssets, (self, that) => self - that),
    Record2.union(externalAssets, _BigInt.sum)
  );
  let extraLovelace = pipe7(
    calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
    Option.getOrUndefined
  );
  let remainingInputs = _Array.differenceWith(isEqualUTxO)(
    inputs,
    selected
  );
  while (extraLovelace) {
    const extraSelected = selectUTxOs(remainingInputs, extraLovelace);
    if (_Array.isEmptyArray(extraSelected)) {
      return [];
    }
    const extraSelectedAssets = sumAssetsFromInputs(extraSelected);
    selected = [...selected, ...extraSelected];
    availableAssets = Record2.union(
      availableAssets,
      extraSelectedAssets,
      _BigInt.sum
    );
    extraLovelace = pipe7(
      calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
      Option.getOrUndefined
    );
    remainingInputs = _Array.differenceWith(isEqualUTxO)(
      remainingInputs,
      selected
    );
  }
  return selected;
};

// src/tx-builder/TxBuilder.ts
import { Effect as Effect17 } from "effect";
function makeTxBuilder(lucidConfig) {
  const config = {
    lucidConfig,
    txBuilder: CML.TransactionBuilder.new(lucidConfig.txbuilderconfig),
    walletInputs: [],
    collectedInputs: [],
    readInputs: [],
    consumedInputs: [],
    totalOutputAssets: {},
    mintedAssets: {},
    scripts: /* @__PURE__ */ new Map(),
    programs: []
  };
  const txBuilder = {
    readFrom: (utxos) => {
      utxos.map((utxo) => {
        if (utxo.scriptRef) {
          const scriptKeyValue = attachScript(utxo.scriptRef);
          config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        }
      });
      const program = readFrom(config, utxos);
      config.programs.push(program);
      return txBuilder;
    },
    collectFrom: (utxos, redeemer) => {
      const program = collectFromUTxO(config, utxos, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    pay: {
      ToAddress: (address, assets) => {
        const program = payToAddress(config, address, assets);
        config.programs.push(program);
        return txBuilder;
      },
      ToAddressWithData: (address, outputDatum, assets, scriptRef) => {
        const program = payToAddressWithData(
          config,
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToContract: (address, outputDatum, assets, scriptRef) => {
        const program = payToContract(
          config,
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    addSigner: (address) => {
      const program = addSigner(config, address);
      config.programs.push(program);
      return txBuilder;
    },
    registerStake: (rewardAddress) => {
      const program = registerStake(config, rewardAddress);
      config.programs.push(program);
      return txBuilder;
    },
    deRegisterStake: (rewardAddress, redeemer) => {
      const program = deRegisterStake(config, rewardAddress, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    withdraw: (rewardAddress, amount, redeemer) => {
      const program = withdraw(config, rewardAddress, amount, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    mintAssets: (assets, redeemer) => {
      const program = mintAssets(config, assets, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    validFrom: (unixTime) => {
      const program = validFrom(config, unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    validTo: (unixTime) => {
      const program = validTo(config, unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    delegateTo: (rewardAddress, poolId, redeemer) => {
      const program = delegateTo(config, rewardAddress, poolId, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    attachMetadata: (label, metadata) => {
      const program = attachMetadata(config, label, metadata);
      config.programs.push(program);
      return txBuilder;
    },
    attach: {
      Script: (script) => {
        const scriptKeyValue = attachScript(script);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      SpendingValidator: (spendingValidator) => {
        const scriptKeyValue = attachSpendingValidator(spendingValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      MintingPolicy: (mintingPolicy) => {
        const scriptKeyValue = attachMintingPolicy(mintingPolicy);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      CertificateValidator: (certValidator) => {
        const scriptKeyValue = attachCertificateValidator(certValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      WithdrawalValidator: (withdrawalValidator) => {
        const scriptKeyValue = attachWithdrawalValidator(withdrawalValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      }
    },
    complete: (options) => makeReturn(
      complete(config, options).pipe(
        Effect17.map((result) => result[2])
      )
    ).unsafeRun(),
    completeProgram: (options) => complete(config, options).pipe(
      Effect17.map((result) => result[2])
    ),
    completeSafe: (options) => makeReturn(
      complete(config, options).pipe(
        Effect17.map((result) => result[2])
      )
    ).safeRun(),
    chainProgram: (options) => complete(config, options),
    chain: (options) => makeReturn(complete(config, options)).unsafeRun(),
    chainSafe: (options) => makeReturn(complete(config, options)).safeRun(),
    config: () => config
  };
  return txBuilder;
}

// src/tx-builder/TxConfig.ts
var makeTxConfig = (protocolParameters, costModels) => {
  const exUnitsPrices = CML.ExUnitPrices.new(
    CML.Rational.new(
      BigInt(protocolParameters.priceMem * 1e8),
      100000000n
    ),
    CML.Rational.new(
      BigInt(protocolParameters.priceStep * 1e8),
      100000000n
    )
  );
  const txBuilderConfig = CML.TransactionBuilderConfigBuilder.new().fee_algo(
    CML.LinearFee.new(
      BigInt(protocolParameters.minFeeA),
      BigInt(protocolParameters.minFeeB)
    )
  ).coins_per_utxo_byte(protocolParameters.coinsPerUtxoByte).pool_deposit(protocolParameters.poolDeposit).key_deposit(protocolParameters.keyDeposit).max_value_size(protocolParameters.maxValSize).max_tx_size(protocolParameters.maxTxSize).ex_unit_prices(exUnitsPrices).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).cost_models(costModels).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).build();
  return txBuilderConfig;
};

// src/lucid-evolution/LucidEvolution.ts
import {
  makeWalletFromAddress,
  makeWalletFromAPI,
  makeWalletFromPrivateKey,
  makeWalletFromSeed
} from "@lucid-evolution/wallet";
var Lucid = async (provider, network) => {
  const protocolParam = await provider.getProtocolParameters();
  const costModels = createCostModels(protocolParam.costModels);
  const config = {
    provider,
    network,
    wallet: void 0,
    costModels,
    txbuilderconfig: makeTxConfig(protocolParam, costModels),
    protocolParameters: protocolParam
  };
  return {
    config: () => config,
    wallet: () => config.wallet,
    overrideUTxOs: (utxos) => config.wallet?.overrideUTxOs(utxos),
    switchProvider: async (provider2) => {
      const protocolParam2 = await provider2.getProtocolParameters();
      const costModels2 = createCostModels(protocolParam2.costModels);
      config.provider = provider2;
      config.costModels = costModels2;
      config.txbuilderconfig = makeTxConfig(protocolParam2, costModels2);
      config.protocolParameters = protocolParam2;
    },
    newTx: () => makeTxBuilder(config),
    fromTx: (tx) => makeTxSignBuilder(
      config,
      CML.Transaction.from_cbor_hex(tx)
    ),
    selectWallet: {
      fromSeed: (seed) => {
        config.wallet = makeWalletFromSeed(config.provider, network, seed);
      },
      fromPrivateKey: (privateKey) => {
        config.wallet = makeWalletFromPrivateKey(
          config.provider,
          network,
          privateKey
        );
      },
      fromAPI: (walletAPI) => {
        config.wallet = makeWalletFromAPI(config.provider, walletAPI);
      },
      fromAddress: (address, utxos) => {
        config.wallet = makeWalletFromAddress(
          config.provider,
          network,
          address,
          utxos
        );
      }
    },
    currentSlot: () => {
      return unixTimeToSlot2(config.network, Date.now());
    },
    utxosAt: (addressOrCredential) => config.provider.getUtxos(addressOrCredential),
    utxosAtWithUnit: (addressOrCredential, unit) => config.provider.getUtxosWithUnit(addressOrCredential, unit),
    utxoByUnit: (unit) => config.provider.getUtxoByUnit(unit),
    utxosByOutRef: (outRefs) => config.provider.getUtxosByOutRef(outRefs),
    delegationAt: config.provider.getDelegation,
    awaitTx: (txHash, checkInterval) => config.provider.awaitTx(txHash, checkInterval),
    datumOf: (utxo, type) => datumOf(config.provider, utxo, type),
    metadataOf: (unit) => metadataOf(config.provider, unit)
  };
};

// src/index.ts
export * from "@lucid-evolution/bip39";
export * from "@lucid-evolution/core-types";
export * from "@lucid-evolution/core-utils";
export * from "@lucid-evolution/plutus";
export * from "@lucid-evolution/provider";
export * from "@lucid-evolution/sign_data";
export * from "@lucid-evolution/utils";
export * from "@lucid-evolution/wallet";
export {
  ERROR_MESSAGE,
  Lucid,
  RunTimeError,
  TxBuilderError,
  TxSignerError,
  TxSubmitError,
  makeRunTimeError,
  makeTxBuilder,
  makeTxSignBuilder,
  signError
};
