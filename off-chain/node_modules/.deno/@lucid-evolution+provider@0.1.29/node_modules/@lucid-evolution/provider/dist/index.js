// src/core.ts
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/blockfrost.ts
import { fromHex } from "@lucid-evolution/core-utils";
import { applyDoubleCborEncoding } from "@lucid-evolution/utils";

// package.json
var package_default = {
  name: "@lucid-evolution/provider",
  version: "0.1.29",
  description: "",
  main: "./dist/index.js",
  types: "./dist/index.d.ts",
  type: "module",
  exports: {
    ".": {
      require: "./dist/index.cjs",
      import: "./dist/index.js",
      types: "./dist/index.d.ts"
    }
  },
  files: [
    "dist"
  ],
  publishConfig: {
    access: "public"
  },
  scripts: {
    build: "tsup src/index.ts --format esm,cjs --dts --clean",
    clean: "rm -rf .turbo && rm -rf node_modules && rm -rf dist",
    test: "vitest run"
  },
  keywords: [],
  author: "",
  license: "MIT",
  browser: {
    "@anastasia-labs/cardano-multiplatform-lib-nodejs": "@anastasia-labs/cardano-multiplatform-lib-browser"
  },
  dependencies: {
    "@anastasia-labs/cardano-multiplatform-lib-browser": "^5.3.1-2",
    "@anastasia-labs/cardano-multiplatform-lib-nodejs": "^5.3.1-2",
    "@effect/schema": "^0.67.16",
    "@lucid-evolution/core-types": "workspace:*",
    "@lucid-evolution/core-utils": "workspace:*",
    "@lucid-evolution/utils": "workspace:*",
    effect: "^3.1.2"
  },
  devDependencies: {
    "@types/node": "^20.12.8",
    tsup: "^8.0.2",
    typescript: "^5.4.5",
    vitest: "^1.6.0"
  }
};

// src/blockfrost.ts
var Blockfrost = class {
  url;
  projectId;
  constructor(url, projectId) {
    this.url = url;
    this.projectId = projectId || "";
  }
  async getProtocolParameters() {
    const result = await fetch(`${this.url}/epochs/latest/parameters`, {
      headers: { project_id: this.projectId, lucid }
    }).then((res) => res.json());
    return {
      minFeeA: parseInt(result.min_fee_a),
      minFeeB: parseInt(result.min_fee_b),
      maxTxSize: parseInt(result.max_tx_size),
      maxValSize: parseInt(result.max_val_size),
      keyDeposit: BigInt(result.key_deposit),
      poolDeposit: BigInt(result.pool_deposit),
      priceMem: parseFloat(result.price_mem),
      priceStep: parseFloat(result.price_step),
      maxTxExMem: BigInt(result.max_tx_ex_mem),
      maxTxExSteps: BigInt(result.max_tx_ex_steps),
      coinsPerUtxoByte: BigInt(result.coins_per_utxo_size),
      collateralPercentage: parseInt(result.collateral_percent),
      maxCollateralInputs: parseInt(result.max_collateral_inputs),
      costModels: result.cost_models
    };
  }
  async getUtxos(addressOrCredential) {
    const queryPredicate = (() => {
      if (typeof addressOrCredential === "string") return addressOrCredential;
      const credentialBech32 = addressOrCredential.type === "Key" ? CML.Ed25519KeyHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      ) : CML.ScriptHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      );
      return credentialBech32;
    })();
    let result = [];
    let page = 1;
    while (true) {
      const pageResult = await fetch(
        `${this.url}/addresses/${queryPredicate}/utxos?page=${page}`,
        { headers: { project_id: this.projectId, lucid } }
      ).then((res) => res.json());
      if (pageResult.error) {
        if (pageResult.status_code === 404) {
          return [];
        } else {
          throw new Error("Could not fetch UTxOs from Blockfrost. Try again.");
        }
      }
      result = result.concat(pageResult);
      if (pageResult.length <= 0) break;
      page++;
    }
    return this.blockfrostUtxosToUtxos(result);
  }
  async getUtxosWithUnit(addressOrCredential, unit) {
    const queryPredicate = (() => {
      if (typeof addressOrCredential === "string") return addressOrCredential;
      const credentialBech32 = addressOrCredential.type === "Key" ? CML.Ed25519KeyHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      ) : CML.ScriptHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      );
      return credentialBech32;
    })();
    let result = [];
    let page = 1;
    while (true) {
      const pageResult = await fetch(
        `${this.url}/addresses/${queryPredicate}/utxos/${unit}?page=${page}`,
        { headers: { project_id: this.projectId, lucid } }
      ).then((res) => res.json());
      if (pageResult.error) {
        if (pageResult.status_code === 404) {
          return [];
        } else {
          throw new Error("Could not fetch UTxOs from Blockfrost. Try again.");
        }
      }
      result = result.concat(pageResult);
      if (pageResult.length <= 0) break;
      page++;
    }
    return this.blockfrostUtxosToUtxos(result);
  }
  async getUtxoByUnit(unit) {
    const addresses = await fetch(
      `${this.url}/assets/${unit}/addresses?count=2`,
      { headers: { project_id: this.projectId, lucid } }
    ).then((res) => res.json());
    if (!addresses || addresses.error) {
      throw new Error("Unit not found.");
    }
    if (addresses.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    const address = addresses[0].address;
    const utxos = await this.getUtxosWithUnit(address, unit);
    if (utxos.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    return utxos[0];
  }
  async getUtxosByOutRef(outRefs) {
    const queryHashes = [...new Set(outRefs.map((outRef) => outRef.txHash))];
    const utxos = await Promise.all(
      queryHashes.map(async (txHash) => {
        const result = await fetch(`${this.url}/txs/${txHash}/utxos`, {
          headers: { project_id: this.projectId, lucid }
        }).then((res) => res.json());
        if (!result || result.error) {
          return [];
        }
        const utxosResult = result.outputs.map(
          (r) => ({
            ...r,
            tx_hash: txHash
          })
        );
        return this.blockfrostUtxosToUtxos(utxosResult);
      })
    );
    return utxos.reduce((acc, utxos2) => acc.concat(utxos2), []).filter(
      (utxo) => outRefs.some(
        (outRef) => utxo.txHash === outRef.txHash && utxo.outputIndex === outRef.outputIndex
      )
    );
  }
  async getDelegation(rewardAddress) {
    const result = await fetch(`${this.url}/accounts/${rewardAddress}`, {
      headers: { project_id: this.projectId, lucid }
    }).then((res) => res.json());
    if (!result || result.error) {
      return { poolId: null, rewards: 0n };
    }
    return {
      poolId: result.pool_id || null,
      rewards: BigInt(result.withdrawable_amount)
    };
  }
  async getDatum(datumHash) {
    const datum = await fetch(`${this.url}/scripts/datum/${datumHash}/cbor`, {
      headers: { project_id: this.projectId, lucid }
    }).then((res) => res.json()).then((res) => res.cbor);
    if (!datum || datum.error) {
      throw new Error(`No datum found for datum hash: ${datumHash}`);
    }
    return datum;
  }
  awaitTx(txHash, checkInterval = 3e3) {
    return new Promise((res) => {
      const confirmation = setInterval(async () => {
        const isConfirmed = await fetch(`${this.url}/txs/${txHash}`, {
          headers: { project_id: this.projectId, lucid }
        }).then((res2) => res2.json());
        if (isConfirmed && !isConfirmed.error) {
          clearInterval(confirmation);
          await new Promise((res2) => setTimeout(() => res2(1), 1e3));
          return res(true);
        }
      }, checkInterval);
    });
  }
  async submitTx(tx) {
    const result = await fetch(`${this.url}/tx/submit`, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        project_id: this.projectId,
        lucid
      },
      body: fromHex(tx)
    }).then((res) => res.json());
    if (!result || result.error) {
      if (result?.status_code === 400) throw new Error(result.message);
      else throw new Error("Could not submit transaction.");
    }
    return result;
  }
  async blockfrostUtxosToUtxos(result) {
    return await Promise.all(
      result.map(async (r) => ({
        txHash: r.tx_hash,
        outputIndex: r.output_index,
        assets: Object.fromEntries(
          r.amount.map(({ unit, quantity }) => [unit, BigInt(quantity)])
        ),
        address: r.address,
        datumHash: !r.inline_datum && r.data_hash || void 0,
        datum: r.inline_datum || void 0,
        scriptRef: r.reference_script_hash ? await (async () => {
          const { type } = await fetch(
            `${this.url}/scripts/${r.reference_script_hash}`,
            {
              headers: { project_id: this.projectId, lucid }
            }
          ).then((res) => res.json());
          if (type === "Native" || type === "native") {
            throw new Error("Native script ref not implemented!");
          }
          const { cbor: script } = await fetch(
            `${this.url}/scripts/${r.reference_script_hash}/cbor`,
            { headers: { project_id: this.projectId, lucid } }
          ).then((res) => res.json());
          return {
            type: type === "plutusV1" ? "PlutusV1" : "PlutusV2",
            script: applyDoubleCborEncoding(script)
          };
        })() : void 0
      }))
    );
  }
};
function datumJsonToCbor(json) {
  const convert = (json2) => {
    if (!isNaN(json2.int)) {
      return CML.PlutusData.new_integer(
        CML.BigInteger.from_str(json2.int.toString())
      );
    } else if (json2.bytes || !isNaN(Number(json2.bytes))) {
      return CML.PlutusData.new_bytes(fromHex(json2.bytes));
    } else if (json2.map) {
      const m = CML.PlutusMap.new();
      json2.map.forEach(({ k, v }) => {
        m.set(convert(k), convert(v));
      });
      return CML.PlutusData.new_map(m);
    } else if (json2.list) {
      const l = CML.PlutusDataList.new();
      json2.list.forEach((v) => {
        l.add(convert(v));
      });
      return CML.PlutusData.new_list(l);
    } else if (!isNaN(json2.constructor)) {
      const l = CML.PlutusDataList.new();
      json2.fields.forEach((v) => {
        l.add(convert(v));
      });
      return CML.PlutusData.new_constr_plutus_data(
        CML.ConstrPlutusData.new(
          CML.BigInteger.from_str(json2.constructor.toString()).as_u64(),
          l
        )
      );
    }
    throw new Error("Unsupported type");
  };
  return convert(json).to_cbor_hex();
}
var lucid = package_default.version;

// src/kupmios.ts
import { fromUnit } from "@lucid-evolution/utils";
var Kupmios = class {
  kupoUrl;
  ogmiosUrl;
  /**
   * @param kupoUrl: http(s)://localhost:1442
   * @param ogmiosUrl: ws(s)://localhost:1337
   */
  constructor(kupoUrl, ogmiosUrl) {
    this.kupoUrl = kupoUrl;
    this.ogmiosUrl = ogmiosUrl;
  }
  async getProtocolParameters() {
    const client = await this.ogmiosWsp("queryLedgerState/protocolParameters");
    return new Promise((res, rej) => {
      client.addEventListener(
        "message",
        (msg) => {
          try {
            const { result } = JSON.parse(msg.data);
            const costModels = {};
            Object.keys(result.plutusCostModels).forEach((v) => {
              const version = v.split(":")[1].toUpperCase();
              const plutusVersion = "Plutus" + version;
              costModels[plutusVersion] = result.plutusCostModels[v];
            });
            const [memNum, memDenom] = result.scriptExecutionPrices.memory.split("/");
            const [stepsNum, stepsDenom] = result.scriptExecutionPrices.cpu.split("/");
            res({
              minFeeA: parseInt(result.minFeeCoefficient),
              minFeeB: parseInt(result.minFeeConstant.ada.lovelace),
              maxTxSize: parseInt(result.maxTransactionSize.bytes),
              maxValSize: parseInt(result.maxValueSize.bytes),
              keyDeposit: BigInt(result.stakeCredentialDeposit.ada.lovelace),
              poolDeposit: BigInt(result.stakePoolDeposit.ada.lovelace),
              priceMem: parseInt(memNum) / parseInt(memDenom),
              priceStep: parseInt(stepsNum) / parseInt(stepsDenom),
              maxTxExMem: BigInt(result.maxExecutionUnitsPerTransaction.memory),
              maxTxExSteps: BigInt(result.maxExecutionUnitsPerTransaction.cpu),
              // NOTE: coinsPerUtxoByte is now called utxoCostPerByte:
              // https://github.com/IntersectMBO/cardano-node/pull/4141
              // Ogmios v6.x calls it minUtxoDepositCoefficient according to the following
              // documentation from its protocol parameters data model:
              // https://github.com/CardanoSolutions/ogmios/blob/master/architectural-decisions/accepted/017-api-version-6-major-rewrite.md#protocol-parameters
              coinsPerUtxoByte: BigInt(result.minUtxoDepositCoefficient),
              collateralPercentage: parseInt(result.collateralPercentage),
              maxCollateralInputs: parseInt(result.maxCollateralInputs),
              costModels
            });
            client.close();
          } catch (e) {
            rej(e);
          }
        },
        { once: true }
      );
    });
  }
  async getUtxos(addressOrCredential) {
    const isAddress = typeof addressOrCredential === "string";
    const queryPredicate = isAddress ? addressOrCredential : addressOrCredential.hash;
    const result = await fetch(
      `${this.kupoUrl}/matches/${queryPredicate}${isAddress ? "" : "/*"}?unspent`
    ).then((res) => res.json());
    return this.kupmiosUtxosToUtxos(result);
  }
  async getUtxosWithUnit(addressOrCredential, unit) {
    const isAddress = typeof addressOrCredential === "string";
    const queryPredicate = isAddress ? addressOrCredential : addressOrCredential.hash;
    const { policyId, assetName } = fromUnit(unit);
    const result = await fetch(
      `${this.kupoUrl}/matches/${queryPredicate}${isAddress ? "" : "/*"}?unspent&policy_id=${policyId}${assetName ? `&asset_name=${assetName}` : ""}`
    ).then((res) => res.json());
    return this.kupmiosUtxosToUtxos(result);
  }
  async getUtxoByUnit(unit) {
    const { policyId, assetName } = fromUnit(unit);
    const result = await fetch(
      `${this.kupoUrl}/matches/${policyId}.${assetName ? `${assetName}` : "*"}?unspent`
    ).then((res) => res.json());
    const utxos = await this.kupmiosUtxosToUtxos(result);
    if (utxos.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    return utxos[0];
  }
  async getUtxosByOutRef(outRefs) {
    const queryHashes = [...new Set(outRefs.map((outRef) => outRef.txHash))];
    const utxos = await Promise.all(
      queryHashes.map(async (txHash) => {
        const result = await fetch(
          `${this.kupoUrl}/matches/*@${txHash}?unspent`
        ).then((res) => res.json());
        return this.kupmiosUtxosToUtxos(result);
      })
    );
    return utxos.reduce((acc, utxos2) => acc.concat(utxos2), []).filter(
      (utxo) => outRefs.some(
        (outRef) => utxo.txHash === outRef.txHash && utxo.outputIndex === outRef.outputIndex
      )
    );
  }
  async getDelegation(rewardAddress) {
    const client = await this.ogmiosWsp(
      "queryLedgerState/rewardAccountSummaries",
      { keys: [rewardAddress] }
    );
    return new Promise((res, rej) => {
      client.addEventListener(
        "message",
        (msg) => {
          try {
            const { result } = JSON.parse(msg.data);
            const delegation = result ? Object.values(result)[0] : {};
            res({
              poolId: delegation?.delegate?.id || null,
              rewards: BigInt(delegation?.rewards?.ada?.lovelace || 0)
            });
            client.close();
          } catch (e) {
            rej(e);
          }
        },
        { once: true }
      );
    });
  }
  async getDatum(datumHash) {
    const result = await fetch(`${this.kupoUrl}/datums/${datumHash}`).then(
      (res) => res.json()
    );
    if (!result || !result.datum) {
      throw new Error(`No datum found for datum hash: ${datumHash}`);
    }
    return result.datum;
  }
  awaitTx(txHash, checkInterval = 3e3) {
    return new Promise((res) => {
      const confirmation = setInterval(async () => {
        const isConfirmed = await fetch(
          `${this.kupoUrl}/matches/*@${txHash}?unspent`
        ).then((res2) => res2.json());
        if (isConfirmed && isConfirmed.length > 0) {
          clearInterval(confirmation);
          await new Promise((res2) => setTimeout(() => res2(1), 1e3));
          return res(true);
        }
      }, checkInterval);
    });
  }
  async submitTx(cbor) {
    const client = await this.ogmiosWsp("submitTransaction", {
      transaction: { cbor }
    });
    return new Promise((res, rej) => {
      client.addEventListener(
        "message",
        (msg) => {
          try {
            const { result } = JSON.parse(msg.data);
            if (result.transaction) res(result.transaction.id);
            else rej(result.error);
            client.close();
          } catch (e) {
            rej(e);
          }
        },
        { once: true }
      );
    });
  }
  kupmiosUtxosToUtxos(utxos) {
    return Promise.all(
      utxos.map(async (utxo) => {
        return {
          txHash: utxo.transaction_id,
          outputIndex: parseInt(utxo.output_index),
          address: utxo.address,
          assets: (() => {
            const a = { lovelace: BigInt(utxo.value.coins) };
            Object.keys(utxo.value.assets).forEach((unit) => {
              a[unit.replace(".", "")] = BigInt(utxo.value.assets[unit]);
            });
            return a;
          })(),
          datumHash: utxo?.datum_type === "hash" ? utxo.datum_hash : null,
          datum: utxo?.datum_type === "inline" ? await this.getDatum(utxo.datum_hash) : null,
          scriptRef: utxo.script_hash && await (async () => {
            const { script, language } = await fetch(
              `${this.kupoUrl}/scripts/${utxo.script_hash}`
            ).then((res) => res.json());
            if (language === "native") {
              return { type: "Native", script };
            } else if (language === "plutus:v1") {
              return {
                type: "PlutusV1",
                script: CML.PlutusV1Script.from_cbor_hex(script).to_cbor_hex()
              };
            } else if (language === "plutus:v2") {
              return {
                type: "PlutusV2",
                script: CML.PlutusV2Script.from_cbor_hex(script).to_cbor_hex()
              };
            }
          })()
        };
      })
    );
  }
  async ogmiosWsp(method, params = {}, id) {
    const client = new WebSocket(this.ogmiosUrl);
    await new Promise((res) => {
      client.addEventListener("open", () => res(1), { once: true });
    });
    client.send(
      JSON.stringify({
        jsonrpc: "2.0",
        method,
        params,
        id
      })
    );
    return client;
  }
};

// src/maestro.ts
import { applyDoubleCborEncoding as applyDoubleCborEncoding2 } from "@lucid-evolution/utils";
import { fromHex as fromHex2 } from "@lucid-evolution/core-utils";
var Maestro = class {
  url;
  apiKey;
  turboSubmit;
  constructor({ network, apiKey, turboSubmit = false }) {
    this.url = `https://${network}.gomaestro-api.org/v1`;
    this.apiKey = apiKey;
    this.turboSubmit = turboSubmit;
  }
  async getProtocolParameters() {
    const timestampedResult = await fetch(`${this.url}/protocol-params`, {
      headers: this.commonHeaders()
    }).then((res) => res.json());
    const result = timestampedResult.data;
    const decimalFromRationalString = (str) => {
      const forwardSlashIndex = str.indexOf("/");
      return parseInt(str.slice(0, forwardSlashIndex)) / parseInt(str.slice(forwardSlashIndex + 1));
    };
    const renameKeysAndSort = (obj, newKeys) => {
      const entries = Object.keys(obj).sort().map((key) => {
        const newKey = newKeys[key] || key;
        return {
          [newKey]: Object.fromEntries(
            Object.entries(obj[key]).sort(
              ([k, _v], [k2, _v2]) => k.localeCompare(k2)
            )
          )
        };
      });
      return Object.assign({}, ...entries);
    };
    return {
      minFeeA: parseInt(result.min_fee_coefficient),
      minFeeB: parseInt(result.min_fee_constant),
      maxTxSize: parseInt(result.max_tx_size),
      maxValSize: parseInt(result.max_value_size),
      keyDeposit: BigInt(result.stake_key_deposit),
      poolDeposit: BigInt(result.pool_deposit),
      priceMem: decimalFromRationalString(result.prices.memory),
      priceStep: decimalFromRationalString(result.prices.steps),
      maxTxExMem: BigInt(result.max_execution_units_per_transaction.memory),
      maxTxExSteps: BigInt(result.max_execution_units_per_transaction.steps),
      coinsPerUtxoByte: BigInt(result.coins_per_utxo_byte),
      collateralPercentage: parseInt(result.collateral_percentage),
      maxCollateralInputs: parseInt(result.max_collateral_inputs),
      costModels: renameKeysAndSort(result.cost_models, {
        "plutus:v1": "PlutusV1",
        "plutus:v2": "PlutusV2"
      })
    };
  }
  async getUtxosInternal(addressOrCredential, unit) {
    const queryPredicate = (() => {
      if (typeof addressOrCredential === "string") {
        return "/addresses/" + addressOrCredential;
      }
      let credentialBech32Query = "/addresses/cred/";
      credentialBech32Query += addressOrCredential.type === "Key" ? CML.Ed25519KeyHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      ) : CML.ScriptHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_shared_vkh"
      );
      return credentialBech32Query;
    })();
    const qparams = new URLSearchParams({
      count: "100",
      ...unit && { asset: unit }
    });
    const result = await this.getAllPagesData(
      async (qry) => await fetch(qry, {
        headers: this.requireAmountsAsStrings(this.commonHeaders())
      }),
      `${this.url}${queryPredicate}/utxos`,
      qparams,
      "Location: getUtxosInternal. Error: Could not fetch UTxOs from Maestro"
    );
    return result.map(this.maestroUtxoToUtxo);
  }
  getUtxos(addressOrCredential) {
    return this.getUtxosInternal(addressOrCredential);
  }
  getUtxosWithUnit(addressOrCredential, unit) {
    return this.getUtxosInternal(addressOrCredential, unit);
  }
  async getUtxoByUnit(unit) {
    const timestampedAddressesResponse = await fetch(
      `${this.url}/assets/${unit}/addresses?count=2`,
      { headers: this.commonHeaders() }
    );
    const timestampedAddresses = await timestampedAddressesResponse.json();
    if (!timestampedAddressesResponse.ok) {
      if (timestampedAddresses.message) {
        throw new Error(timestampedAddresses.message);
      }
      throw new Error(
        "Location: getUtxoByUnit. Error: Couldn't perform query. Received status code: " + timestampedAddressesResponse.status
      );
    }
    const addressesWithAmount = timestampedAddresses.data;
    if (addressesWithAmount.length === 0) {
      throw new Error("Location: getUtxoByUnit. Error: Unit not found.");
    }
    if (addressesWithAmount.length > 1) {
      throw new Error(
        "Location: getUtxoByUnit. Error: Unit needs to be an NFT or only held by one address."
      );
    }
    const address = addressesWithAmount[0].address;
    const utxos = await this.getUtxosWithUnit(address, unit);
    if (utxos.length > 1) {
      throw new Error(
        "Location: getUtxoByUnit. Error: Unit needs to be an NFT or only held by one address."
      );
    }
    return utxos[0];
  }
  async getUtxosByOutRef(outRefs) {
    const qry = `${this.url}/transactions/outputs`;
    const body = JSON.stringify(
      outRefs.map(({ txHash, outputIndex }) => `${txHash}#${outputIndex}`)
    );
    const utxos = await this.getAllPagesData(
      async (qry2) => await fetch(qry2, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...this.requireAmountsAsStrings(this.commonHeaders())
        },
        body
      }),
      qry,
      new URLSearchParams({}),
      "Location: getUtxosByOutRef. Error: Could not fetch UTxOs by references from Maestro"
    );
    return utxos.map(this.maestroUtxoToUtxo);
  }
  async getDelegation(rewardAddress) {
    const timestampedResultResponse = await fetch(
      `${this.url}/accounts/${rewardAddress}`,
      { headers: this.commonHeaders() }
    );
    if (!timestampedResultResponse.ok) {
      return { poolId: null, rewards: 0n };
    }
    const timestampedResult = await timestampedResultResponse.json();
    const result = timestampedResult.data;
    return {
      poolId: result.delegated_pool || null,
      rewards: BigInt(result.rewards_available)
    };
  }
  async getDatum(datumHash) {
    const timestampedResultResponse = await fetch(
      `${this.url}/datums/${datumHash}`,
      {
        headers: this.commonHeaders()
      }
    );
    if (!timestampedResultResponse.ok) {
      if (timestampedResultResponse.status === 404) {
        throw new Error(`No datum found for datum hash: ${datumHash}`);
      } else {
        throw new Error(
          "Location: getDatum. Error: Couldn't successfully perform query. Received status code: " + timestampedResultResponse.status
        );
      }
    }
    const timestampedResult = await timestampedResultResponse.json();
    return timestampedResult.data.bytes;
  }
  awaitTx(txHash, checkInterval = 3e3) {
    return new Promise((res) => {
      const confirmation = setInterval(async () => {
        const isConfirmedResponse = await fetch(
          `${this.url}/transactions/${txHash}/cbor`,
          {
            headers: this.commonHeaders()
          }
        );
        if (isConfirmedResponse.ok) {
          await isConfirmedResponse.json();
          clearInterval(confirmation);
          await new Promise((res2) => setTimeout(() => res2(1), 1e3));
          return res(true);
        }
      }, checkInterval);
    });
  }
  async submitTx(tx) {
    let queryUrl = `${this.url}/txmanager`;
    queryUrl += this.turboSubmit ? "/turbosubmit" : "";
    const response = await fetch(queryUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        Accept: "text/plain",
        ...this.commonHeaders()
      },
      body: fromHex2(tx)
    });
    const result = await response.text();
    if (!response.ok) {
      if (response.status === 400) throw new Error(result);
      else {
        throw new Error(
          "Could not submit transaction. Received status code: " + response.status
        );
      }
    }
    return result;
  }
  commonHeaders() {
    return { "api-key": this.apiKey, lucid: lucid2 };
  }
  requireAmountsAsStrings(obj) {
    return { ...obj, "amounts-as-strings": "true" };
  }
  maestroUtxoToUtxo(result) {
    return {
      txHash: result.tx_hash,
      outputIndex: result.index,
      assets: (() => {
        const a = {};
        result.assets.forEach((am) => {
          a[am.unit] = BigInt(am.amount);
        });
        return a;
      })(),
      address: result.address,
      datumHash: result.datum ? result.datum.type == "inline" ? void 0 : result.datum.hash : void 0,
      datum: result.datum?.bytes,
      scriptRef: result.reference_script ? result.reference_script.type == "native" ? void 0 : {
        type: result.reference_script.type == "plutusv1" ? "PlutusV1" : "PlutusV2",
        script: applyDoubleCborEncoding2(result.reference_script.bytes)
      } : void 0
    };
  }
  async getAllPagesData(getResponse, qry, paramsGiven, errorMsg) {
    let nextCursor = null;
    let result = [];
    while (true) {
      if (nextCursor !== null) {
        paramsGiven.set("cursor", nextCursor);
      }
      const response = await getResponse(`${qry}?` + paramsGiven);
      const pageResult = await response.json();
      if (!response.ok) {
        throw new Error(
          `${errorMsg}. Received status code: ${response.status}`
        );
      }
      nextCursor = pageResult.next_cursor;
      result = result.concat(pageResult.data);
      if (nextCursor == null) break;
    }
    return result;
  }
};
var lucid2 = package_default.version;

// src/koios/koios.ts
import * as S2 from "@effect/schema/Schema";
import { fromHex as fromHex3 } from "@lucid-evolution/core-utils";
import { applyDoubleCborEncoding as applyDoubleCborEncoding3, fromUnit as fromUnit2 } from "@lucid-evolution/utils";

// src/koios/schema.ts
import * as S from "@effect/schema/Schema";
var ProtocolParametersSchema = S.Struct({
  epoch_no: S.Number,
  min_fee_a: S.Number,
  min_fee_b: S.Number,
  max_block_size: S.Number,
  max_tx_size: S.Number,
  max_bh_size: S.Number,
  key_deposit: S.BigInt,
  pool_deposit: S.BigInt,
  max_epoch: S.Number,
  optimal_pool_count: S.Number,
  influence: S.Number,
  monetary_expand_rate: S.Number,
  treasury_growth_rate: S.Number,
  decentralisation: S.Number,
  extra_entropy: S.NullOr(S.String),
  protocol_major: S.Number,
  protocol_minor: S.Number,
  min_utxo_value: S.String,
  min_pool_cost: S.String,
  nonce: S.String,
  block_hash: S.NullOr(S.String),
  cost_models: S.Struct({
    PlutusV1: S.Array(S.Number),
    PlutusV2: S.Array(S.Number)
  }),
  price_mem: S.Number,
  price_step: S.Number,
  max_tx_ex_mem: S.BigIntFromNumber,
  max_tx_ex_steps: S.BigIntFromNumber,
  max_block_ex_mem: S.Number,
  max_block_ex_steps: S.Number,
  max_val_size: S.Number,
  collateral_percent: S.Number,
  max_collateral_inputs: S.Number,
  coins_per_utxo_size: S.BigInt
});
var KoiosAssetSchema = S.Struct({
  policy_id: S.String,
  asset_name: S.NullOr(S.String),
  fingerprint: S.String,
  decimals: S.Number,
  quantity: S.String
});
var KoiosUTxOSchema = S.Struct({
  tx_hash: S.String,
  tx_index: S.Number,
  block_height: S.NullOr(S.Number),
  value: S.String,
  datum_hash: S.NullOr(S.String),
  inline_datum: S.NullOr(
    S.Struct({
      bytes: S.String,
      value: S.Object
    })
  ),
  reference_script: S.NullOr(
    S.Struct({
      hash: S.String,
      size: S.Number,
      type: S.String,
      bytes: S.String,
      value: S.NullOr(S.Object)
    })
  ),
  asset_list: S.NullOr(S.Array(KoiosAssetSchema))
});
var KoiosAddressInfoSchema = S.Array(
  S.NullishOr(
    S.Struct({
      address: S.String,
      balance: S.String,
      stake_address: S.NullOr(S.String),
      script_address: S.Boolean,
      utxo_set: S.Array(KoiosUTxOSchema)
    })
  )
);
var KoiosInputOutputSchema = S.Struct({
  payment_addr: S.Struct({
    bech32: S.String,
    cred: S.String
  }),
  stake_addr: S.NullOr(S.String),
  tx_hash: S.String,
  tx_index: S.Number,
  value: S.String,
  datum_hash: S.NullOr(S.String),
  inline_datum: S.NullOr(
    S.Struct({
      bytes: S.String,
      value: S.Object
    })
  ),
  reference_script: S.NullOr(
    S.Struct({
      hash: S.String,
      size: S.Number,
      type: S.String,
      bytes: S.String,
      value: S.NullOr(S.Object)
    })
  ),
  asset_list: S.Union(S.Array(KoiosAssetSchema), S.String)
});
var KoiosTxInfoSchema = S.Struct({
  tx_hash: S.String,
  block_hash: S.String,
  block_height: S.Number,
  epoch_no: S.Number,
  epoch_slot: S.Number,
  absolute_slot: S.Number,
  tx_timestamp: S.Number,
  tx_block_index: S.Number,
  tx_size: S.Number,
  total_output: S.String,
  fee: S.String,
  deposit: S.String,
  invalid_before: S.NullOr(S.String),
  invalid_after: S.NullOr(S.String),
  collateral_inputs: S.NullOr(S.Array(KoiosInputOutputSchema)),
  collateral_output: S.NullOr(KoiosInputOutputSchema),
  reference_inputs: S.NullOr(S.Array(KoiosInputOutputSchema)),
  inputs: S.Array(KoiosInputOutputSchema),
  outputs: S.Array(KoiosInputOutputSchema),
  withdrawals: S.NullOr(
    S.Array(
      S.Struct({
        amount: S.String,
        stake_addr: S.String
      })
    )
  ),
  assets_minted: S.NullOr(S.Array(KoiosAssetSchema)),
  metadata: S.NullOr(S.Object),
  certificates: S.NullOr(
    S.Array(
      S.Struct({
        index: S.Number,
        type: S.String,
        info: S.NullOr(S.Object)
      })
    )
  ),
  native_scripts: S.NullOr(
    S.Array(
      S.Struct({
        script_hash: S.String,
        script_json: S.Object
      })
    )
  ),
  plutus_contracts: S.NullOr(
    S.Array(
      S.Struct({
        address: S.String,
        spends_input: S.NullOr(
          S.Struct({
            tx_hash: S.String,
            tx_index: S.Number
          })
        ),
        script_hash: S.String,
        bytecode: S.String,
        size: S.Number,
        valid_contract: S.Boolean,
        input: S.Struct({
          redeemer: S.Struct({
            purpose: S.Literal("spend", "mint", "cert", "reward"),
            fee: S.String,
            unit: S.Struct({
              steps: S.String,
              mem: S.String
            }),
            datum: S.Struct({
              hash: S.NullOr(S.String),
              value: S.NullOr(S.Object)
            })
          }),
          datum: S.Struct({
            hash: S.NullOr(S.String),
            value: S.NullOr(S.Object)
          })
        })
      })
    )
  )
});

// src/koios/koios.ts
import { Effect, pipe, Schedule } from "effect";
import { ArrayFormatter } from "@effect/schema";
var Koios = class {
  baseUrl;
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  async getProtocolParameters() {
    const result = await fetch(`${this.baseUrl}/epoch_params?limit=1`).then(
      (res) => res.json()
    );
    const param = S2.decodeUnknownSync(ProtocolParametersSchema)(result[0]);
    return {
      minFeeA: param.min_fee_a,
      minFeeB: param.min_fee_b,
      maxTxSize: param.max_tx_size,
      maxValSize: param.max_val_size,
      keyDeposit: param.key_deposit,
      poolDeposit: param.pool_deposit,
      priceMem: param.price_mem,
      priceStep: param.price_step,
      maxTxExMem: param.max_tx_ex_mem,
      maxTxExSteps: param.max_tx_ex_steps,
      coinsPerUtxoByte: param.coins_per_utxo_size,
      collateralPercentage: param.collateral_percent,
      maxCollateralInputs: param.max_collateral_inputs,
      costModels: {
        PlutusV1: Object.fromEntries(
          param.cost_models.PlutusV1.map((value, index) => [
            index.toString(),
            value
          ])
        ),
        PlutusV2: Object.fromEntries(
          param.cost_models.PlutusV2.map((value, index) => [
            index.toString(),
            value
          ])
        )
      }
    };
  }
  async getUtxos(addressOrCredential) {
    if (typeof addressOrCredential === "string") {
      const body = {
        _addresses: [addressOrCredential]
      };
      const result = await fetch(`${this.baseUrl}/address_info`, {
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        method: "POST",
        body: JSON.stringify(body)
      }).then((res) => res.json());
      const parsedResult = S2.decodeUnknownSync(KoiosAddressInfoSchema)(
        result
      )[0];
      return parsedResult ? parsedResult.utxo_set.map(
        (koiosUTXO) => toUTxO(koiosUTXO, parsedResult.address)
      ) : [];
    } else {
      throw Error("getUtxos by Credential Type is not supported in Koios yet.");
    }
  }
  async getUtxosWithUnit(addressOrCredential, unit) {
    if (typeof addressOrCredential === "string") {
      const utxos = await this.getUtxos(addressOrCredential);
      if (utxos && utxos.length > 0) {
        return utxos.filter((utxo) => {
          const keys = Object.keys(utxo.assets);
          return keys.length > 0 && keys.includes(unit);
        });
      } else {
        return [];
      }
    } else {
      throw Error(
        "getUtxosWithUnit by Credential Type is not supported in Koios yet."
      );
    }
  }
  async getUtxoByUnit(unit) {
    let { policyId, assetName } = fromUnit2(unit);
    assetName = String(assetName);
    const assetAddresses = await fetch(
      `${this.baseUrl}/asset_addresses?_asset_policy=${policyId}&_asset_name=${assetName}`
    ).then((res) => res.json());
    if (Array.isArray(assetAddresses) && assetAddresses.length > 0) {
      if (assetAddresses.length > 1) {
        throw new Error("Unit needs to be an NFT or only held by one address.");
      }
      const utxos = await this.getUtxos(
        assetAddresses[0].payment_address
      );
      const result = utxos.find((utxo) => {
        const keys = Object.keys(utxo.assets);
        return keys.length > 0 && keys.includes(unit);
      });
      if (result) {
        return result;
      }
    }
    throw new Error("Unit not found.");
  }
  async getUtxosByOutRef(outRefs) {
    const utxos = [];
    const body = {
      _tx_hashes: [...new Set(outRefs.map((outRef) => outRef.txHash))]
    };
    const result = await fetch(`${this.baseUrl}/tx_info`, {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify(body)
    }).then((res) => res.json());
    const parsedResult = S2.decodeUnknownSync(S2.Array(KoiosTxInfoSchema))(
      result
    )[0];
    if (parsedResult) {
      return parsedResult.outputs.map(
        (koiosInputOutput) => toUTxO(
          {
            tx_hash: koiosInputOutput.tx_hash,
            tx_index: koiosInputOutput.tx_index,
            block_height: null,
            value: koiosInputOutput.value,
            datum_hash: koiosInputOutput.datum_hash,
            inline_datum: koiosInputOutput.inline_datum,
            reference_script: koiosInputOutput.reference_script,
            //NOTE: Koios api returns collateral_output like  asset_list: "[]", instead of asset_list: []
            asset_list: typeof koiosInputOutput.asset_list === "string" ? [] : koiosInputOutput.asset_list
          },
          koiosInputOutput.payment_addr.bech32
        )
      );
    } else {
      return [];
    }
  }
  async getDelegation(rewardAddress) {
    const body = {
      _stake_addresses: [rewardAddress]
    };
    const result = await fetch(`${this.baseUrl}/account_info`, {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify(body)
    }).then((res) => res.json());
    if (Array.isArray(result) && result.length > 0) {
      return {
        poolId: result[0].delegated_pool || null,
        rewards: BigInt(result[0].rewards_available)
      };
    } else {
      throw new Error("No Delegation Found by Reward Address");
    }
  }
  async getDatum(datumHash) {
    const body = {
      _datum_hashes: [datumHash]
    };
    const datum = await fetch(`${this.baseUrl}/datum_info`, {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify(body)
    }).then((res) => res.json());
    if (Array.isArray(datum) && datum.length > 0) {
      return datum[0].bytes;
    } else {
      throw new Error("No Datum Found by Datum Hash");
    }
  }
  awaitTx(txHash, checkInterval = 2e4) {
    const body = {
      _tx_hashes: [txHash]
    };
    const request = {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify(body)
    };
    const program = pipe(
      Effect.tryPromise({
        //TODO: use tx_status api
        try: () => fetch(`${this.baseUrl}/tx_info`, request),
        catch: (error) => new Error(String(error))
      }),
      Effect.flatMap(
        (response) => !response.ok ? Effect.fail(new Error(`${response.status} ${response.statusText}`)) : Effect.succeed(response)
      ),
      Effect.flatMap(
        (response) => Effect.tryPromise({
          try: () => response.json(),
          catch: (error) => new Error(String(error))
        })
      ),
      Effect.flatMap(
        (json) => S2.decodeUnknown(S2.Array(KoiosTxInfoSchema), { errors: "first" })(json)
      ),
      Effect.catchTag(
        "ParseError",
        (e) => Effect.fail(ArrayFormatter.formatErrorSync(e))
      ),
      Effect.repeat({
        schedule: Schedule.exponential(checkInterval),
        until: (result) => result.length > 0
      }),
      Effect.orDie,
      Effect.as(true)
    );
    return Effect.runPromise(program);
  }
  async submitTx(tx) {
    const result = await fetch(`${this.baseUrl}/submittx`, {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/cbor"
      },
      method: "POST",
      body: fromHex3(tx)
    }).then((res) => res.json());
    const TxHashSchema = S2.String;
    const isTxHash = S2.is(TxHashSchema);
    if (!isTxHash(result)) {
      throw new Error(JSON.stringify(result));
    }
    return result;
  }
};
var toUTxO = (koiosUTxO, address) => ({
  txHash: koiosUTxO.tx_hash,
  outputIndex: koiosUTxO.tx_index,
  assets: (() => {
    const a = {};
    if (koiosUTxO.asset_list) {
      koiosUTxO.asset_list.forEach((am) => {
        a[am.policy_id + am.asset_name] = BigInt(am.quantity);
      });
    }
    a["lovelace"] = BigInt(koiosUTxO.value);
    return a;
  })(),
  address,
  datumHash: koiosUTxO.inline_datum ? void 0 : koiosUTxO.datum_hash,
  datum: koiosUTxO.inline_datum ? koiosUTxO.inline_datum.bytes : void 0,
  scriptRef: koiosUTxO.reference_script ? koiosUTxO.reference_script.type == "plutusV1" ? {
    type: "PlutusV1",
    script: applyDoubleCborEncoding3(koiosUTxO.reference_script.bytes)
  } : {
    type: "PlutusV2",
    script: applyDoubleCborEncoding3(koiosUTxO.reference_script.bytes)
  } : void 0
});
export {
  Blockfrost,
  Koios,
  Kupmios,
  Maestro,
  datumJsonToCbor
};
